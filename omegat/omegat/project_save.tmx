<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.3.1_0_99222d65" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>*Limitations*</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T214708Z" creationid="eldesh" creationdate="20191221T214708Z">
        <seg>*制限*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:ref:`functional-scheme` and :tacn:`function induction`</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T220621Z" creationid="eldesh" creationdate="20191221T220621Z">
        <seg>:ref:`functional-scheme` と :tacn:`function induction`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:ref:`thecoqcommands`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145020Z" creationid="yamarten" creationdate="20181104T145020Z">
        <seg>:ref:`thecoqcommands`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@binders } : @sort := @ident₀ {?</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191507Z" creationid="eldesh" creationdate="20191221T191507Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@binders }`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191456Z" creationid="eldesh" creationdate="20191221T191456Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A *caveat*, however, is that records cannot appear in mutually inductive (or co-inductive) definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201335Z" creationid="eldesh" creationdate="20191221T200543Z">
        <seg>注意点として、しかしながら、レコードは相互帰納的 (または余帰納的) 定義の中に現れることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A canonical structure is an instance of a record/structure type that can be used to solve unification problems involving a projection applied to an unknown structure instance (an implicit argument) and a value.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T182609Z" creationid="eldesh" creationdate="20191225T182543Z">
        <seg>正準構造とはレコードまたはストラクチャ型のインスタンスの一つであり、それを未知のストラクチャインスタンス (暗黙引数) と値に射影を実行することで単一化問題を解くのに使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A commented version of sources of the |Coq| standard library (including only the specifications, the proofs are removed) is available at https://coq.inria.fr/stdlib/.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150204Z" creationid="yamarten" creationdate="20181104T150204Z">
        <seg>|Coq| 標準ライブラリのコメント付きソースコード (仕様のみで、証明を省いたもの)は https://coq.inria.fr/stdlib/ で閲覧できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A companion volume to this reference manual, the |Coq| Tutorial, is aimed at gently introducing new users to developing proofs in |Coq| without assuming prior knowledge of type theory.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145957Z" creationid="yamarten" creationdate="20181104T145957Z">
        <seg>このマニュアルと対を成す |Coq| チュートリアルは、新規ユーザが型理論の知識なしに |Coq| で証明を構築できるようになるまで、優しく導入することを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more precise description is given below.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T131250Z" creationid="eldesh" creationdate="20191221T220812Z">
        <seg>より詳細な説明を以下で与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A text file `INSTALL` that comes with the sources explains how to install |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150123Z" creationid="yamarten" creationdate="20181104T150123Z">
        <seg>ソースに付属するテキストファイル `INSTALL` では、 |Coq| をインストールする方法について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Addendum</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150239Z" creationid="yamarten" creationdate="20181104T150239Z">
        <seg>付録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, user-written :g:`match` constructs on primitive records are desugared into substitution of the projections, they cannot be printed back as :g:`match` constructs.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T164515Z" creationid="eldesh" creationdate="20191225T164515Z">
        <seg>さらに、プリミティブレコード上のユーザ記述の :g:`match` は射影の代入への脱糖され、それらは :g:`match` として表示することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adds blocks of implicit types with different specifications.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T132934Z" creationid="eldesh" creationdate="20191226T132934Z">
        <seg>異なる仕様を伴った暗黙型のブロックを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advanced recursive functions</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T212337Z" creationid="eldesh" creationdate="20191221T212337Z">
        <seg>高度な再帰関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All logical judgments in |Coq| are typing judgments.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T101610Z" creationid="yamarten" creationdate="20181007T100201Z">
        <seg>|Coq| における論理的判断は全て型付け判断です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All services of the |Coq| proof assistant are accessible by interpretation of a command language called *the vernacular*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144825Z" creationid="yamarten" creationdate="20181007T112922Z">
        <seg>|Coq| が提供する全てのサービスは、 *Vernacular* と呼ばれるコマンド言語を読み込ませることで利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the following syntax allows creating objects by using named fields, as shown in this grammar.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T192325Z" creationid="eldesh" creationdate="20191221T192325Z">
        <seg>この文法で示されるように、代わりに以下の構文で名前付きフィールドを使うことでオブジェクトを作ることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative syntax for projections based on a dot notation is available:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194622Z" creationid="eldesh" creationdate="20191221T194622Z">
        <seg>射影のためドット記法に基づいた代替構文が使用可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unfolded primitive projection application obeys the rule above, while the folded version delta-reduces to the unfolded version.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160741Z" creationid="eldesh" creationdate="20191225T160541Z">
        <seg>非畳み込みプリミティブ射影適用は上の規則にしたがい、一方畳み込み版は非畳み込み版へデルタ簡約します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assume that :token:`qualid` denotes an object ``(Build_struct`` |c_1| … |c_n| ``)`` in the structure :g:`struct` of which the fields are |x_1|, …, |x_n|.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T183129Z" creationid="eldesh" creationdate="20191225T183129Z">
        <seg>:token:`qualid` がフィールドが |x_1|, …, |x_n| であるような構造 :g:`struct` の中のあるオブジェクト ``(Build_struct`` |c_1| … |c_n| ``)`` を示すと仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic generation of induction schemes for non-recursive records defined with the ``Record`` keyword can be activated with the ``Nonrecursive Elimination Schemes`` option (see :ref:`proofschemes-induction-principles`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201328Z" creationid="eldesh" creationdate="20191221T201328Z">
        <seg>``Record`` キーワードによって定義された非-再帰的レコードの帰納スキームの自動生成は ``Nonrecursive Elimination Schemes`` オプション (:ref:`proofschemes-induction-principles` 参照) によって有効化することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calculus of Inductive Constructions</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181110T055945Z" creationid="yamarten" creationdate="20181110T055945Z">
        <seg>Calculus of Inductive Constructions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Canonical structures</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T182327Z" creationid="eldesh" creationdate="20191225T182327Z">
        <seg>正準構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Canonical structures are particularly useful when mixed with coercions and strict implicit arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T184259Z" creationid="eldesh" creationdate="20191225T184259Z">
        <seg>正準構造は型強制と厳密暗黙引数と混用したときに特に有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapters :ref:`gallinaspecificationlanguage` and :ref:`extensionsofgallina` describe the concrete syntax as well as the meaning of programs, theorems and proofs in the Calculus of Inductive Constructions.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145106Z" creationid="yamarten" creationdate="20181104T145106Z">
        <seg>:ref:`gallinaspecificationlanguage` および :ref:`extensionsofgallina` の章では、構文および Calculus of Inductive Constructions におけるプログラムや証明・定理の意味について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`calculusofinductiveconstructions` is a mathematical description of the formalism.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145128Z" creationid="yamarten" creationdate="20181104T145128Z">
        <seg>:ref:`calculusofinductiveconstructions` の章は数学の形式的な説明です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`thecoqlibrary` describes the standard library of |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145114Z" creationid="yamarten" creationdate="20181104T145114Z">
        <seg>:ref:`thecoqlibrary` の章では |Coq| の標準ライブラリについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`themodulesystem` describes the module system.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145130Z" creationid="yamarten" creationdate="20181104T145130Z">
        <seg>:ref:`themodulesystem` の章ではモジュールシステムについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>"requests to the environment"が指すものがわかっていない。環境ってどの辺りなんだろう。宣言とかの話なのか、Setみたいなより広い話を含んでいるのか。</note>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`vernacularcommands` presents all commands (we call them *vernacular commands*) that are not directly related to interactive proving: requests to the environment, complete or partial evaluation, loading and compiling files.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145429Z" creationid="yamarten" creationdate="20181104T145429Z">
        <seg>:ref:`vernacularcommands` の章では、対話的証明と直接的には関係のないコマンド (*Vernacular コマンド*) を全て挙げます。コマンドは、環境への要求、完全/部分的な評価、ファイルの読み込みやコンパイルなどを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <note>the chapter とは？</note>
      <tuv lang="EN-US">
        <seg>Coercions and records in section :ref:`coercions-classes-as-records` of the chapter devoted to coercions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T205044Z" creationid="eldesh" creationdate="20191221T204147Z">
        <seg>そのチャプターのセクション :ref:`coercions-classes-as-records` のコアーションとレコードはコアーションに費やされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compatibility Projections and :g:`match`</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T162633Z" creationid="eldesh" creationdate="20191225T162633Z">
        <seg>互換性射影と :g:`match`</seg>
      </tuv>
    </tu>
    <tu>
      <note>唐突に「Coq」から外れる縦棒。どうも付けるとsmallcapクラスが付くっぽいのだけど、スモールキャピタルにはなっているわけでもなく、特に意味は無さそう。
</note>
      <tuv lang="EN-US">
        <seg>Coq has an interactive mode in which commands are interpreted as the user types them in from the keyboard and a compiled mode where commands are processed from a file.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T114048Z" creationid="yamarten" creationdate="20181007T113510Z">
        <seg>Coq には、ユーザが入力した端からコマンドを実行していく対話モードと、ファイルに書かれたコマンドを順に実行していくコンパイルモードがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines a recursive function by well-founded recursion.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133844Z" creationid="eldesh" creationdate="20191222T133844Z">
        <seg>整礎再帰によって再帰関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines the not recursive function `ident` as if declared with `Definition`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T131308Z" creationid="eldesh" creationdate="20191221T221023Z">
        <seg>非-再帰関数 `ident` をあたかも `Definition` によって定義されたかのように定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines the structural recursive function `ident` as if declared with ``Fixpoint``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133514Z" creationid="eldesh" creationdate="20191222T133514Z">
        <seg>構造的再帰関数 `ident` を ``Fixpoint`` により定義されたかのように定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the ``{…}`` annotation, different definition mechanisms are used by ``Function``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144640Z" creationid="eldesh" creationdate="20191221T220752Z">
        <seg>``{…}`` という注釈に依存して、``Function`` によって異なる定義機構が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the annotation, the user is left with some proof obligations that will be used to define the function.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145620Z" creationid="eldesh" creationdate="20191222T135037Z">
        <seg>注釈に依存して、その関数を定義するのに使われるいくらかの証明課題はユーザに残されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the definition of the one-constructor inductive definition, all the errors of inductive definitions, as described in Section :ref:`gallina-inductive-definitions`, may also occur.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T203528Z" creationid="eldesh" creationdate="20191221T203528Z">
        <seg>コンストラクタが一つの帰納的定義を定義しているとき、セクション :ref:`gallina-inductive-definitions` で説明される帰納的定義の全てのエラーも起こる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eta-conversion allows to define dependent elimination for these types as well.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T145640Z" creationid="eldesh" creationdate="20191225T145640Z">
        <seg>その上、Eta 変換はこれらの型について依存除去を定義することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if the record type has parameters, these do not appear at applications of the projection, considerably reducing the sizes of terms when manipulating parameterized records and type checking time.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T133448Z" creationid="eldesh" creationdate="20191225T133448Z">
        <seg>そのレコード型がパラメータを持っていたとしても、これらは射影の適用には現れず、パラメータ化されたレコードを操作するときの項のサイズや型検査時間を大幅に減少させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of tactics are described in Chapter :ref:`detailedexamplesoftactics`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145621Z" creationid="yamarten" creationdate="20181104T145621Z">
        <seg>タクティックの具体例は :ref:`detailedexamplesoftactics` の章で説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions of |Gallina|</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184133Z" creationid="eldesh" creationdate="20191221T184133Z">
        <seg>|Gallina| の拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, :token:`binders` are parameters of the record.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184039Z" creationid="eldesh" creationdate="20191221T184039Z">
        <seg>最後に、:token:`binders` はレコードのパラメータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Chapter :ref:`coqintegrateddevelopmentenvironment` describes CoqIDE.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145816Z" creationid="yamarten" creationdate="20181104T145816Z">
        <seg>最後に、 :ref:`coqintegrateddevelopmentenvironment` の章で、 CoqIDE について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the |SSR| proof language is presented in Chapter :ref:`thessreflectprooflanguage`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145630Z" creationid="yamarten" creationdate="20181104T145630Z">
        <seg>最後に、証明言語 |SSR| について :ref:`thessreflectprooflanguage` の章で説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>compile mode じゃなかったのかよ。</note>
      <tuv lang="EN-US">
        <seg>First in Chapter :ref:`thecoqcommands`, the usage of `coqc` (batch mode) and `coqtop` (interactive mode) with their options is described.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145714Z" creationid="yamarten" creationdate="20181104T145714Z">
        <seg>まず、 :ref:`thecoqcommands` の章で、`coqc` (コンパイルモード) と `coqtop` (対話モード) の使い方およびオプションについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First the macro generates a variant type definition with just one constructor: :n:`Variant @ident {?</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191437Z" creationid="eldesh" creationdate="20191221T191223Z">
        <seg>まずマクロは高々一つのコンストラクタをもつバリアント型定義を生成します: :n:`Variant @ident { @binders } : @sort := @ident₀ { @binders }` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a given field :token:`ident`, its type is :g:`forall binders, type`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183456Z" creationid="eldesh" creationdate="20191221T183448Z">
        <seg>あるフィールド :token:`ident` が与えられた場合、その型は :g:`forall binders, type` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For compatibility, the parameters still appear to the user when printing terms even though they are absent in the actual AST manipulated by the kernel.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T144549Z" creationid="eldesh" creationdate="20191225T144549Z">
        <seg>互換性のため、カーネルにより操作された実際のAST中には存在しないものであっても項を表示する時にパラメータはユーザに表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each of them, the canonical structure of which it is a projection is indicated.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185241Z" creationid="eldesh" creationdate="20191225T185208Z">
        <seg>それぞれについて、その正準構造が射影であるということを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example it is better to define plus like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143302Z" creationid="eldesh" creationdate="20191221T214351Z">
        <seg>例えば plus はこのように定義した方が:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the above example gives the following output:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185236Z" creationid="eldesh" creationdate="20191225T185236Z">
        <seg>例えば、上の例は以下の出力を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, we might have: :n:`Record @ident @binders : @sort := { @ident₁ : @type₁ ; @ident₂ := @term₂ ; @ident₃ : @type₃ }`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T190954Z" creationid="eldesh" creationdate="20191221T185415Z">
        <seg>例えば、:n:`Record @ident @binders : @sort := { @ident₁ : @type₁ ; @ident₂ := @term₂ ; @ident₃ : @type₃ }` があるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For now, dependent cases are not treated for non structurally terminating functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143648Z" creationid="eldesh" creationdate="20191221T215336Z">
        <seg>今のところ、依存ケースは非-構造的停止関数として扱われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function does not support partial application of the function being defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143555Z" creationid="eldesh" creationdate="20191221T215107Z">
        <seg>Function は定義された関数の部分適用はサポートしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further compatibility printing can be deactivated thanks to the ``Printing Primitive Projection Compatibility`` option which governs the printing of pattern matching over primitive records.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T144857Z" creationid="eldesh" creationdate="20191225T144857Z">
        <seg>さらなる互換表示は ``Printing Primitive Projection Compatibility`` オプションで非有効化することができ、これはプリミティブレコード上のパターンマッチを抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T184307Z" creationid="eldesh" creationdate="20191225T184307Z">
        <seg>これが例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to read this book</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144922Z" creationid="yamarten" creationdate="20181104T144922Z">
        <seg>この文書の読み方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to start and stop proofs, do multiple proofs in parallel is explained in Chapter :ref:`proofhandling`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145435Z" creationid="yamarten" creationdate="20181104T145435Z">
        <seg>どのように証明を始め、終わればいいのか、どうすれば証明を並行して進めることができるかは、 :ref:`proofhandling` の章で説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this feature does not work for non structurally recursive functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T213839Z" creationid="eldesh" creationdate="20191221T213839Z">
        <seg>しかし、この帰納は非-構造的再帰関数については動きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, to take the :math:`{\delta}` flag into account, projections can be in two states: folded or unfolded.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160629Z" creationid="eldesh" creationdate="20191225T160438Z">
        <seg>しかし、:math:`{\delta}` フラグを考慮すると、射影は 畳み込み または 非畳み込み という二つの状態になり得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If :token:`sort` is omitted, the default sort is `\Type`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183210Z" creationid="eldesh" creationdate="20191221T183103Z">
        <seg>:token:`sort` が省略された場合は、デフォルトのソートは `\Type` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a field is named `_` then no projection is built for it.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194250Z" creationid="eldesh" creationdate="20191221T194250Z">
        <seg>もしフィールドの名前が `_` ならばそれのための射影は構築されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a same field occurs in several canonical structures, then only the structure declared first as canonical is considered.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185258Z" creationid="eldesh" creationdate="20191225T184830Z">
        <seg>いくつかの正準構造に同じフィールドが現れた場合は、初めに定義された構造のみが正準と認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is omitted, the default name ``Build_``\ :token:`ident`, where :token:`ident` is the record name, is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183052Z" creationid="eldesh" creationdate="20191221T183052Z">
        <seg>それが省略された場合、デフォルトの名称である ``Build_``\ :token:`ident` ここで :token:`ident` はレコード名、が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set, use the record syntax (shown above) as the default display format.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193126Z" creationid="eldesh" creationdate="20191221T193126Z">
        <seg>セットすると、レコード構文 (上記) をデフォルト表示形式として使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit types of variables</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T131740Z" creationid="eldesh" creationdate="20191226T131740Z">
        <seg>変数の暗黙の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter :ref:`tactics`, all commands that realize one or more steps of the proof are presented: we call them *tactics*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145557Z" creationid="yamarten" creationdate="20181104T145557Z">
        <seg>:ref:`tactics` の章では、証明の1つまたは複数のステップを成すコマンド (*タクティック*) を全て挙げます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>とっくの昔に消えているような気がする。</note>
      <tuv lang="EN-US">
        <seg>In a second step, the user can read also the tutorial on recursive types (document `RecTutorial.ps`).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150007Z" creationid="yamarten" creationdate="20181104T150007Z">
        <seg>その後は、再帰型についてのチュートリアル (`RecTutorial.ps`) を読むのもいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each case, `term` is the object projected and the other arguments are the parameters of the inductive type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200629Z" creationid="eldesh" creationdate="20191221T195516Z">
        <seg>いずれの場合も、`term` は射影されたオブジェクトであり、他の引数は帰納型のパラメータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, the :cmd:`Record` macro is more general than the usual record types, since it allows also for “manifest” expressions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T165910Z" creationid="eldesh" creationdate="20191221T165600Z">
        <seg>実際は、:cmd:`Record` マクロは普通のレコード型より一般的であり、”マニフェスト” 式のためのものでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In interactive mode, users can develop their theories and proofs step by step, and query the system for available theorems and definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T122200Z" creationid="yamarten" creationdate="20181007T122200Z">
        <seg>対話モードでは、ユーザは順を追って証明を構築したり、利用できる定理や定義をシステムに問い合わせたりできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194409Z" creationid="eldesh" creationdate="20191221T194349Z">
        <seg>我々の扱っている例では:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the expression:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T171148Z" creationid="eldesh" creationdate="20191221T171148Z">
        <seg>この式では:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the fourth part more practical tools are documented.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145717Z" creationid="yamarten" creationdate="20181104T145650Z">
        <seg>第4部はより実用的なツールについて文書化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case the types can be recursive and eta-conversion is disallowed.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T154757Z" creationid="eldesh" creationdate="20191225T154757Z">
        <seg>この場合は型は再帰でき、eta 変換は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this sense, the :cmd:`Record` construction allows defining “signatures”.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T165956Z" creationid="eldesh" creationdate="20191221T165956Z">
        <seg>この場合、:cmd:`Record` は ”シグネチャ” の定義をすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexes</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150216Z" creationid="yamarten" creationdate="20181104T150216Z">
        <seg>索引</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Induction schemes are automatically generated for inductive records.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201102Z" creationid="eldesh" creationdate="20191221T201102Z">
        <seg>帰納スキームは帰納的レコードについて自動的に生成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Installation</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150013Z" creationid="yamarten" creationdate="20181104T150013Z">
        <seg>インストール方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T034937Z" creationid="yamarten" creationdate="20181007T033312Z">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be activated for printing with</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194813Z" creationid="eldesh" creationdate="20191221T194813Z">
        <seg>それは以下によって表示を有効にすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can happen that the definition of a projection is impossible.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201457Z" creationid="eldesh" creationdate="20191221T201457Z">
        <seg>射影の定義が不可能なことが起こり得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is actually a wrapper for several ways of defining a function *and other useful related objects*, namely: an induction principle that reflects the recursive structure of the function (see :tacn:`function induction`) and its fixpoint equality.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T142420Z" creationid="eldesh" creationdate="20191221T212941Z">
        <seg>それは実際には関数 *と他の便利な関連オブジェクト* を定義するいくつかの方法のラッパーであり、具体的には: その関数の再帰構造を反映する帰納法の原理 (:tacn:`function induction` 参照) とその不動点等式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is divided in six chapters.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145403Z" creationid="yamarten" creationdate="20181104T145403Z">
        <seg>ここは6つの章に分かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to bind variable names to a given type (e.g. in a development using arithmetic, it may be convenient to bind the names `n` or `m` to the type ``nat`` of natural numbers).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T131945Z" creationid="eldesh" creationdate="20191226T131935Z">
        <seg>変数名を与えられた型に束縛することが可能です (例: 算術を使う開発の中で、名前 `n` や `m` を自然数である ``nat`` 型に束縛すると便利かもしれません)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a specification language named |Gallina|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T080633Z" creationid="yamarten" creationdate="20181007T080342Z">
        <seg>Coqは、 |Gallina| と呼ばれる仕様記述言語を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its syntax is described in the grammar below.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T165519Z" creationid="eldesh" creationdate="20191221T165438Z">
        <seg>構文は以下で説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let us define the rational :math:`1/2`:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191921Z" creationid="eldesh" creationdate="20191221T191921Z">
        <seg>有理数 :math:`1/2` を定義してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let us now see the work done by the ``Record`` macro.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191542Z" creationid="eldesh" creationdate="20191221T190420Z">
        <seg>``Record`` マクロによって行われる動作を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>License</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150242Z" creationid="yamarten" creationdate="20181104T150242Z">
        <seg>ライセンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like in ``Fixpoint``, the decreasing argument must be given (unless the function is not recursive), but it might not necessarily be *structurally* decreasing.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T213200Z" creationid="eldesh" creationdate="20191221T213200Z">
        <seg>``Fixpoint`` のように、(関数が再帰していないときでさえ) 減少する引数を与えなければいけません、しかしそれが *構造的に* 減少している必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Links to several tutorials can be found at https://coq.inria.fr/documentation and https://github.com/coq/coq/wiki#coq-tutorials</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T035722Z" creationid="yamarten" creationdate="20181007T035722Z">
        <seg>https://coq.inria.fr/documentation や https://github.com/coq/coq/wiki#coq-tutorials には、幾つかのチュートリアルへのリンクがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List of additional documentation</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145841Z" creationid="yamarten" creationdate="20181104T145841Z">
        <seg>その他の文書一覧</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More generally, a record may have explicitly defined (a.k.a.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T190931Z" creationid="eldesh" creationdate="20191221T185102Z">
        <seg>より一般的には、レコードは明示的に定義されたフィールド (別名 マニフェスト) を持ち得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover the following are defined:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T131318Z" creationid="eldesh" creationdate="20191221T221053Z">
        <seg>さらに以下のものが定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, |Coq|’s compiler provides an output file containing a compact representation of its input.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144902Z" creationid="yamarten" creationdate="20181104T144902Z">
        <seg>さらに、 |Coq| コンパイラは、入力のコンパクトな表現を持つ出力ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, the manual has some structure that is explained below.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145002Z" creationid="yamarten" creationdate="20181104T145002Z">
        <seg>とはいえ、このマニュアルも以下のような構造を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the user level, primitive projections can be used as a replacement for the usual defined ones, although there are a few notable differences.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T133701Z" creationid="eldesh" creationdate="20191225T133701Z">
        <seg>ユーザレベルでは、いくらか注目すべき違いはありますが、プリミティブ射影は普通に定義されたそれを置き換えるのに使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once proof obligations are discharged, the following objects are defined:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145855Z" creationid="eldesh" creationdate="20191222T135441Z">
        <seg>証明課題が解決されると、以下のオブジェクトが定義されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can distinguish them from applications of the primitive projection if the :flag`Printing Primitive Projection Parameters` option is off: For a primitive projection application, parameters are printed as underscores while for the compatibility projections they are printed as usual.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T164349Z" creationid="eldesh" creationdate="20191225T164222Z">
        <seg>:flag`Printing Primitive Projection Parameters` オプションがオフになっているとそれらとプリミティブ射影の適用と区別することが出来ます。プリミティブ射影適用のときは、パラメータはアンダースコアとして表示される一方、互換性射影は普通に表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only `ident` is defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144444Z" creationid="eldesh" creationdate="20191221T220441Z">
        <seg>`ident` だけが定義されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only `ident` is defined; the induction scheme will not be generated.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144255Z" creationid="eldesh" creationdate="20191221T215758Z">
        <seg>`ident` のみが定義され、帰納スキームは生成されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionally, you can enhance it with the minor mode Company-Coq :cite:`Pit16` (see https://github.com/cpitclaudel/company-coq).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150319Z" creationid="yamarten" creationdate="20181104T150319Z">
        <seg>また、マイナーモード Company-Coq :cite:`Pit16` (https://github.com/cpitclaudel/company-coq) で拡張することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options A and B are not elected.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150310Z" creationid="yamarten" creationdate="20181104T150310Z">
        <seg>オプションAおよびBは選択しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise said, :token:`qualid` is canonically used to extend the field |c_i| into a complete structure built on |c_i|.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T184130Z" creationid="eldesh" creationdate="20191225T184130Z">
        <seg>別の言い方をすると、:token:`qualid` はフィールド |c_i| を |c_i| 上に構築した完全な構造に拡張するために規範的に使われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters of the function are bound in `term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134806Z" creationid="eldesh" creationdate="20191222T134806Z">
        <seg>その関数のパラメータは `term` 中で抑えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters of the function are bound in `term`\ ;</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134430Z" creationid="eldesh" creationdate="20191222T134430Z">
        <seg>関数のパラメータは `term`\ 中で抑えられます;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please report.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T220449Z" creationid="eldesh" creationdate="20191221T220449Z">
        <seg>報告してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practical tools</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150232Z" creationid="yamarten" creationdate="20181104T150232Z">
        <seg>実用ツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preamble</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150219Z" creationid="yamarten" creationdate="20181104T150219Z">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primitive Projections</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T131511Z" creationid="eldesh" creationdate="20191225T131511Z">
        <seg>プリミティブ射影</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primitive Record Types</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134212Z" creationid="eldesh" creationdate="20191225T134212Z">
        <seg>プリミティブレコード型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primitive projections extended the Calculus of Inductive Constructions with a new binary term constructor `r.(p)` representing a primitive projection `p` applied to a record object `r` (i.e., primitive projections are always applied).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T133504Z" creationid="eldesh" creationdate="20191225T133134Z">
        <seg>プリミティブ射影は Calculus of Inductive Constructions を新たな二項構築子 `r.(p)` で拡張し、これはあるレコードオブジェクト `r` に適用されるプリミティブ射影 `p` です (つまり、プリミティブ射影は常に適用されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To:
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T035013Z" creationid="yamarten" creationdate="20181007T035013Z">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To:
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To: 
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T035446Z" creationid="yamarten" creationdate="20181007T035446Z">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To: 
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Projections obey the usual ``simpl`` flags of the ``Arguments`` command in particular.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T161032Z" creationid="eldesh" creationdate="20191225T161032Z">
        <seg>特に射影は、``Arguments`` コマンドの通常の ``simpl`` フラグに従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proof-General is available at https://proofgeneral.github.io/.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150315Z" creationid="yamarten" creationdate="20181104T150315Z">
        <seg>Proof-General は https://proofgeneral.github.io/から入手可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Record types</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T164758Z" creationid="eldesh" creationdate="20191221T164758Z">
        <seg>レコード型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records  cannot  be  defined  as  part  of  mutually  inductive  (or co-inductive) definitions,  whether with records only  or mixed with standard definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T203221Z" creationid="eldesh" creationdate="20191221T203221Z">
        <seg>レコードは、レコードのみであっても標準定義との混合であっても、相互帰納的 (または余帰納的) 定義の一部として定義することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records defined with the ``Record`` keyword are not allowed to be recursive (references to the record's name in the type of its field raises an  error).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200639Z" creationid="eldesh" creationdate="20191221T195837Z">
        <seg>``Record`` キーワードで定義されたレコードは再帰することは許されません (レコード名への参照がそのフィールドの型の中にあるとエラーが起きる)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160237Z" creationid="eldesh" creationdate="20191225T160237Z">
        <seg>簡約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark here that the fields ``Rat_bottom_cond`` depends on the field ``bottom`` and ``Rat_irred_cond`` depends on both ``top`` and ``bottom``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191027Z" creationid="eldesh" creationdate="20191221T190253Z">
        <seg>ここで注意すべきはフィールド ``Rat_bottom_cond`` がフィールド ``bottom`` に依存し、 ``Rat_irred_cond`` が ``top`` と ``bottom`` の両方に依存していることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark that the type of a particular identifier may depend on a previously-given identifier.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183949Z" creationid="eldesh" creationdate="20191221T183949Z">
        <seg>注目すべきは、特定の識別子の型は前に与えられた識別子に依存し得ることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark: Proof obligations are presented as several subgoals belonging to a Lemma `ident`\ :math:`_{\sf tcc}`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T150212Z" creationid="eldesh" creationdate="20191222T141818Z">
        <seg>注意: 証明課題は補題 `ident`\ :math:`_{\sf tcc}` に付随するいくつかのサブゴールとして提示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark: To obtain the right principle, it is better to put rigid parameters of the function as first arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T214637Z" creationid="eldesh" creationdate="20191221T214118Z">
        <seg>注意: 正しい原理を得るには、第一引数として関数の固定されたパラメータを与えるのがより良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the documentation of functional induction (:tacn:`function induction`) and ``Functional Scheme`` (:ref:`functional-scheme`) for how to use the induction principle to easily reason about the function.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T214113Z" creationid="eldesh" creationdate="20191221T214113Z">
        <seg>どのように帰納法の原理を使って簡単にその関数について論じるかについては関数的帰納法 (:tacn:`function induction`) と ``Functional Scheme`` (:ref:`functional-scheme`) のドキュメントを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the table of contents for a complete list.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145836Z" creationid="yamarten" creationdate="20181104T145836Z">
        <seg>全ての項目を知りたい場合は、目次を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies a set of qualids which are displayed as constructors.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193816Z" creationid="eldesh" creationdate="20191221T193816Z">
        <seg>コンストラクタとして表示される qualid の集合を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>qualids って何？</note>
      <tuv lang="EN-US">
        <seg>Specifies a set of qualids which are displayed as records.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193637Z" creationid="eldesh" creationdate="20191221T193600Z">
        <seg>レコードとして表示される qualid の集合を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax of Record projections</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194831Z" creationid="eldesh" creationdate="20191221T194831Z">
        <seg>レコード射影構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table of contents</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150213Z" creationid="yamarten" creationdate="20181104T150213Z">
        <seg>目次</seg>
      </tuv>
    </tu>
    <tu>
      <note>as well asのニュアンスを落としてるので、「仕様記述言語のはずでは？」となりそうな気もする</note>
      <tuv lang="EN-US">
        <seg>Terms of |Gallina| can represent programs as well as properties of these programs and proofs of these properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T081041Z" creationid="yamarten" creationdate="20181007T081041Z">
        <seg>|Gallina| の項はプログラム・プログラムの性質・性質の証明を表現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to :g:`nat_setoid` declared as canonical, the implicit arguments :g:`A` and :g:`B` can be synthesized in the next statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185303Z" creationid="eldesh" creationdate="20191225T184648Z">
        <seg>:g:`nat_setoid` が正準として定義されているおかげで、次のステートメント内で暗黙引数 :g:`A` と :g:`B` が合成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The :cmd:`Record` construction is a macro allowing the definition of records as is done in many programming languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184600Z" creationid="eldesh" creationdate="20191221T165051Z">
        <seg>:cmd:`Record` は多くのプログラミング言語で行われるようにレコードを定義できるようにするマクロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Gallina specification language</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181110T115315Z" creationid="yamarten" creationdate="20181110T115315Z">
        <seg>仕様記述言語 Gallina</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ``Function`` construction also enjoys the ``with`` extension to define mutually recursive definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T142946Z" creationid="eldesh" creationdate="20191221T213800Z">
        <seg>``Function`` による構成はさらに ``with`` 拡張により相互再帰定義を定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ``{}`` annotation is mandatory and must be one of the following:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134030Z" creationid="eldesh" creationdate="20191222T134030Z">
        <seg>``{}`` の注釈は強制であり、以下のうちの一つでないといけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `coqtop` read-eval-print-loop can also be used directly, for debugging purposes.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144829Z" creationid="yamarten" creationdate="20181104T111736Z">
        <seg>デバッグのために、 read-eval-print-loop である `coqtop` を直接用いることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic reduction rule of a primitive projection is |p_i| ``(Build_``\ `R` |t_1| … |t_n|\ ``)`` :math:`{\rightarrow_{\iota}}` |t_i|.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160326Z" creationid="eldesh" creationdate="20191225T160326Z">
        <seg>プリミティブ射影の基本的な簡約規則は |p_i| ``(Build_``\ `R` |t_1| … |t_n|\ ``)`` :math:`{\rightarrow_{\iota}}` |t_i| です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of `ident` uses an incorrect elimination for `ident` (see :cmd:`Fixpoint` and :ref:`Destructors`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202633Z" creationid="eldesh" creationdate="20191221T202037Z">
        <seg>`ident` のボディーは `ident` に不正な除去を使っている (:cmd:`Fixpoint` と :ref:`Destructors` 参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The command for that is</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T132008Z" creationid="eldesh" creationdate="20191226T132008Z">
        <seg>そのためのコマンドは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiled mode acts as a proof checker taking a file containing a whole development in order to ensure its correctness.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144849Z" creationid="yamarten" creationdate="20181104T144849Z">
        <seg>コンパイルモードは、開発したもの全てを受け取り、その正当性を保証する証明チェッカとして機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiled mode is run with the `coqc` command.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144910Z" creationid="yamarten" creationdate="20181104T144910Z">
        <seg>コンパイルモードは `coqc` コマンドで実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complete documentation of canonical structures can be found in :ref:`canonicalstructures`; here only a simple example is given.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T182728Z" creationid="eldesh" creationdate="20191225T182728Z">
        <seg>正準構造の完全なドキュメントは :ref:`canonicalstructures` で見つけられます; ここでは単純な例のみを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding grammar rules are given in the preceding grammar.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200603Z" creationid="eldesh" creationdate="20191221T195009Z">
        <seg>対応する文法規則は前述の文法の中で与えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The defined type enjoys eta-conversion definitionally, that is the generalized form of surjective pairing for records: `r` ``= Build_``\ `R` ``(``\ `r`\ ``.(``\ |p_1|\ ``) …`` `r`\ ``.(``\ |p_n|\ ``))``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T154211Z" creationid="eldesh" creationdate="20191225T154211Z">
        <seg>定義された型は定義的に eta 変換を使うことが出来、それは `r` ``= Build_``\ `R` ``(``\ `r`\ ``.(``\ |p_1|\ ``) …`` `r`\ ``.(``\ |p_n|\ ``))`` というレコードの全射ペアリングの一般的な形です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effect of the command is to automatically set the type of bound variables starting with `ident` (either `ident` itself or `ident` followed by one or more single quotes, underscore or digits) to be `type` (unless the bound variable is already declared with an explicit type in which case, this latter type is considered).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T132509Z" creationid="eldesh" creationdate="20191226T132204Z">
        <seg>このコマンドの効果は `ident` で始まる　(`ident` 自身または `ident` に一つ以上のシングルクォート、アンダースコア、数字が続く) 束縛変数の型を自動的に `type` (その束縛変数が明示的な型とともに既に定義されている場合でない限り、後者の型と見なされる) に設定するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fields do not have to be in any particular order, nor do they have to be all present if the missing ones can be inferred or prompted for (see :ref:`programs`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193302Z" creationid="eldesh" creationdate="20191221T192858Z">
        <seg>フィールドは特定の順序になっている必要はなく、もし足りないものが推論され得るか入力を促される (:ref:`programs` 参照) ならば、それらは全てが存在する必要もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fifth part documents a number of advanced features, including coercions, canonical structures, typeclasses, program extraction, and specialized solvers and tactics.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145822Z" creationid="yamarten" creationdate="20181104T145822Z">
        <seg>第5部では、型強制・正準構造・型クラス・プログラム抽出・特殊なソルバとタクティックといった、いくつかの高度な機能について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first part describes the specification language, |Gallina|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145011Z" creationid="yamarten" creationdate="20181104T145011Z">
        <seg>第1部では、仕様記述言語 |Gallina| について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fixpoint equation of `ident`: `ident_equation`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145055Z" creationid="eldesh" creationdate="20191222T133620Z">
        <seg>`ident`: `ident_equation` という形の不動点方程式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following experimental command is available when the ``FunInd`` library has been loaded via ``Require Import FunInd``:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T212441Z" creationid="eldesh" creationdate="20191221T212441Z">
        <seg>以下の実験的なコマンドは ``FunInd`` ライブラリが ``Require Import FunInd`` によってロードされたときに有効になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following settings let you control the display format for types:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193010Z" creationid="eldesh" creationdate="20191221T193010Z">
        <seg>以下の設定は型の表示形式をコントロールします:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generation of the graph relation (`R_ident`) succeeded but the induction principle could not be built.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144409Z" creationid="eldesh" creationdate="20191221T220426Z">
        <seg>グラフ関係 (`R_ident`) の生成は成功したが、その帰納法の原理は構築できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generation of the graph relation (`R_ident`) used to compute the induction scheme of ident raised a typing error.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144251Z" creationid="eldesh" creationdate="20191221T215701Z">
        <seg>ident の帰納法の原理を算出するのに使われるグラフ関係 (`R_ident`) の生成は型付けエラーを発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>クレジットへのリンクは張らないのか？</note>
      <tuv lang="EN-US">
        <seg>The history of this formalism as well as pointers to related work are provided in a separate chapter; see *Credits*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The identifiers inside the brackets are the names of fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183245Z" creationid="eldesh" creationdate="20191221T183245Z">
        <seg>ブラケットの中の識別子はフィールド名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inductive `R_ident` corresponding to the graph of `ident` (silently);</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133242Z" creationid="eldesh" creationdate="20191222T133242Z">
        <seg>帰納的 `R_ident` は (暗黙に) `ident` のグラフに対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interactive mode is generally run with the help of an IDE, such as CoqIDE, documented in :ref:`coqintegrateddevelopmentenvironment`, Emacs with Proof-General :cite:`Asp00` [#PG]_, or jsCoq to run Coq in your browser (see https://github.com/ejgallego/jscoq).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T161431Z" creationid="yamarten" creationdate="20181104T111701Z">
        <seg>対話モードは一般的に, CoqIDE (:ref:`coqintegrateddevelopmentenvironment` にて記載)やProof-General :cite:`Asp00` [#PG]_ を入れた Emacs 、またはブラウザ上で動作する jsCoq (https://github.com/ejgallego/jscoq) のようなIDEの助けを借りて実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150221Z" creationid="yamarten" creationdate="20181104T150221Z">
        <seg>言語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language to combine these tactics into complex proof strategies is given in Chapter :ref:`ltac`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145611Z" creationid="yamarten" creationdate="20181104T145611Z">
        <seg>これらのタクティックを組み合わせて複雑な証明戦略を作るための言語については :ref:`ltac` の章で述べています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lemma `ident`\ :math:`_{\sf tcc}` which collects all proof obligations in one property;</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T135650Z" creationid="eldesh" creationdate="20191222T135553Z">
        <seg>補題 `ident`\ :math:`_{\sf tcc}` これは全ての証明課題を集めて一つの性質にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lemmas `ident`\ :math:`_{\sf terminate}` and `ident`\ :math:`_{\sf F}` which is needed to be inlined during extraction of ident.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T135808Z" creationid="eldesh" creationdate="20191222T135808Z">
        <seg>補題 `ident`\ :math:`_{\sf terminate}` と `ident`\ :math:`_{\sf F}` これは indent のエクストラクションをする間にインライン化するために必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The macro generates also, when it is possible, the projection functions for destructuring an object of type `\ident`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194125Z" creationid="eldesh" creationdate="20191221T194125Z">
        <seg>そのマクロはさらに、それが可能な時は `\ident` 型のオブジェクトをデストラクトするための射影関数をも生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of this declaration is to define a function ident, similarly to ``Fixpoint`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T142624Z" creationid="eldesh" creationdate="20191221T213020Z">
        <seg>この定義の意味は関数 ident を定義することで、``Fixpoint`` に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The module ``Recdef`` of the standard library must be loaded for this feature.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133949Z" creationid="eldesh" creationdate="20191222T133949Z">
        <seg>この機能を使うには標準ライブラリの ``Recdef`` モジュールがロードされていないといけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name `ident` already exists in the environment (see :cmd:`Axiom`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202047Z" creationid="eldesh" creationdate="20191221T201857Z">
        <seg>名前 `ident` が既に環境中に存在する (:cmd:`Axiom` 参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional identifier following ``:=`` is the name of its constructor.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T182809Z" creationid="eldesh" creationdate="20191221T182809Z">
        <seg>``:=`` に続くオプショナルな識別子はそのコンストラクタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order must be well-founded.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134747Z" creationid="eldesh" creationdate="20191222T134747Z">
        <seg>その順序は整礎でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The point of the {} annotation is to name the decreasing argument *and* to describe which kind of decreasing criteria must be used to ensure termination of recursive calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T142851Z" creationid="eldesh" creationdate="20191221T213320Z">
        <seg>{} 注釈のポイントは減少する引数に名前をつけること *そして* 再帰呼び出しの停止性を保証するためにどの種類の減少基準を使うべきなのかを説明することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proof engine</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150224Z" creationid="yamarten" creationdate="20181104T150224Z">
        <seg>証明エンジン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The record name `ident` appears in the type of its fields, but uses the keyword ``Record``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202802Z" creationid="eldesh" creationdate="20191221T202744Z">
        <seg>レコード名 `ident` がそのフィールドの型の中に現れているが、``Record`` キーワードを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same objects as above;</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133526Z" creationid="eldesh" creationdate="20191222T133526Z">
        <seg>上と同じオブジェクト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same objects as with the struct;</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145922Z" creationid="eldesh" creationdate="20191222T135519Z">
        <seg>struct を用いたときと同じオブジェクト;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second part describes the proof engine.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145355Z" creationid="yamarten" creationdate="20181104T145355Z">
        <seg>第2部では、証明エンジンについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The set of rational numbers may be defined as:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191017Z" creationid="eldesh" creationdate="20191221T190001Z">
        <seg>有理数の集合は以下のように定義されるかもしれません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third part describes how to extend the syntax of |Coq| in Chapter :ref:`syntaxextensionsandinterpretationscopes` and how to define new induction principles in Chapter :ref:`proofschemes`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145639Z" creationid="yamarten" creationdate="20181104T145639Z">
        <seg>第3部は、 :ref:`syntaxextensionsandinterpretationscopes` の章で|Coq| の構文の拡張方法を、 :ref:`proofschemes` の章で帰納法の原理を新たに定義する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the projections `ident` depends on previous projections which themselves could not be defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202454Z" creationid="eldesh" creationdate="20191221T202454Z">
        <seg>`ident` の射影の型がそれ自身の以前の射影に依存していると定義できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The underlying formal language of |Coq| is a *Calculus of Inductive Constructions* (|Cic|) whose inference rules are presented in this chapter.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181110T110830Z" creationid="yamarten" creationdate="20181110T110830Z">
        <seg>|Coq| の基礎となる形式言語は *Calculus of Inductive Constructions* (|Cic|) と呼ばれる。この章では、 |Cic| の推論規則について説明する。</seg>
      </tuv>
    </tu>
    <tu>
      <note>「compiles to its specification」ってなんだ。</note>
      <tuv lang="EN-US">
        <seg>The very heart of the |Coq| system is the type checking algorithm that checks the correctness of proofs, in other words that checks that a program complies to its specification.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T102409Z" creationid="yamarten" creationdate="20181007T101423Z">
        <seg>|Coq| システムの心臓部は型検査アルゴリズムで、これは証明の正しさを検査します。言い換えれば、このアルゴリズムはプログラムがその仕様に準拠するか検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The way this recursive function is defined is the subject of several papers by Yves Bertot and Antonia Balaa on the one hand, and Gilles Barthe, Julien Forest, David Pichardie, and Vlad Rusu on the other hand.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T141611Z" creationid="eldesh" creationdate="20191222T141611Z">
        <seg>この方法により再帰関数が定義される方法は、一方で Yves Bertot と Antonia Balaa による、もう一方で Gilles Barthe、Julien Forest、David Pichardie、Vlad Rusu によるいくつかの論文の主題です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The |Coq| standard library</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150201Z" creationid="yamarten" creationdate="20181104T150201Z">
        <seg>|Coq| 標準ライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The |Coq| system is designed to develop mathematical proofs, and especially to write formal specifications, programs and to verify that programs are correct with respect to their specifications.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T040420Z" creationid="yamarten" creationdate="20181007T035904Z">
        <seg>|Coq| は、数学的な証明を構築するためにデザインされました。特に、形式仕様やプログラムを記述したり、プログラムが仕様に沿っていることを検証することを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, each time an equation of the form ``(``\ |x_i| ``_)`` |eq_beta_delta_iota_zeta| |c_i| has to be solved during the type checking process, :token:`qualid` is used as a solution.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T183439Z" creationid="eldesh" creationdate="20191225T183402Z">
        <seg>すると、型検査の過程でそれぞれ ``(``\ |x_i| ``_)`` |eq_beta_delta_iota_zeta| |c_i| という形の方程式を解く必要があり、:token:`qualid` が解として使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>distributionのいい感じの訳語が欲しい。</note>
      <tuv lang="EN-US">
        <seg>Then, in Chapter :ref:`utilities`, various utilities that come with the |Coq| distribution are presented.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145806Z" creationid="yamarten" creationdate="20181104T145806Z">
        <seg>次に、 :ref:`utilities` の章で、 |Coq| ディストリビューションに付属する様々なユーティリティについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are currently two ways to introduce primitive records types:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T144942Z" creationid="eldesh" creationdate="20191225T144942Z">
        <seg>今のところプリミティブレコード型を導入するには二つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <note>オプション(Setするやつ)についての索引は無視？</note>
      <tuv lang="EN-US">
        <seg>There is a global index, and a number of specific indexes for tactics, vernacular commands, and error messages and warnings.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144950Z" creationid="yamarten" creationdate="20181104T144950Z">
        <seg>総合索引に加え、タクティックやコマンド、エラーメッセージ・警告に特化した索引があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is currently no way to input unfolded primitive projections at the user-level, and one must use the :flag:`Printing Primitive Projection Compatibility` to display unfolded primitive projections as matches and distinguish them from folded ones.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T161423Z" creationid="eldesh" creationdate="20191225T161423Z">
        <seg>現在のところはユーザレベルで非畳み込みプリミティブ射影を入力する方法は無く、非畳み込みプリミティブ射影をマッチとして表示し、それらを畳み込みのそれと区別するには:flag:`Printing Primitive Projection Compatibility` を使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be three reasons:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201816Z" creationid="eldesh" creationdate="20191221T201816Z">
        <seg>3通りの可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are used when elaborating partial applications of the projection.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T163922Z" creationid="eldesh" creationdate="20191225T163922Z">
        <seg>これらの定数はその射影の部分適用の精緻化のときに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kind of record types differ from their traditional versions in the sense that dependent elimination is not available for them and only non-dependent case analysis can be defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T155555Z" creationid="eldesh" creationdate="20191225T155335Z">
        <seg>これらの種類のレコード型は、依存除去が出来ず、非依存場合分けのみが定義できるという意味での伝統的なバージョンとは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These projection functions are given the names of the corresponding fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194207Z" creationid="eldesh" creationdate="20191221T194207Z">
        <seg>これらの射影関数は対応するフィールド名から与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These proofs are: proofs that each recursive call is actually decreasing with respect to the given criteria, and (if the criteria is `wf`) a proof that the ordering relation is well-founded.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145659Z" creationid="eldesh" creationdate="20191222T135258Z">
        <seg>これらの証明は: 各再帰呼び出しが実際に与えられた基準に照らして減少することの証明であり、そして (もしその基準が `wf` ならば) その順序関係は整礎である証明です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows to precisely mimic the usual unfolding rules of constants.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160913Z" creationid="eldesh" creationdate="20191225T160913Z">
        <seg>これは通常の定数の展開規則と細部に渡って似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be changed by unsetting the :flag:`Printing Primitive Projection Parameters` flag.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T144624Z" creationid="eldesh" creationdate="20191225T144624Z">
        <seg>これは :flag:`Printing Primitive Projection Parameters` フラグをアンセットすることで変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command can be seen as a generalization of ``Fixpoint``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T212519Z" creationid="eldesh" creationdate="20191221T212519Z">
        <seg>このコマンドは ``Fixpoint`` の一般化と見なすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command declares :token:`qualid` as a canonical structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T182845Z" creationid="eldesh" creationdate="20191225T182845Z">
        <seg>このコマンドは :token:`qualid` を正準構造として定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This compatibility option (on by default) governs the printing of pattern matching over primitive records.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134151Z" creationid="eldesh" creationdate="20191225T134151Z">
        <seg>この互換性オプション (デフォルトで有効) はプリミティブレコード上でのパターンマッチの表示を抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This compatibility option reconstructs internally omitted parameters at printing time (even though they are absent in the actual AST manipulated by the kernel).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134030Z" creationid="eldesh" creationdate="20191225T134030Z">
        <seg>この互換オプションは表示時に内部的に省略されたパラメータを再構成します (たとえばそれらがカーネルに操作された実際のASTには存在しないものであっても)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This displays the list of global names that are components of some canonical structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185111Z" creationid="eldesh" creationdate="20191225T185111Z">
        <seg>これはいくつかの正準構造のコンポーネントのグローバルな名前のリストを表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is the Reference Manual of the |Coq| proof assistant.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T034931Z" creationid="yamarten" creationdate="20181007T033738Z">
        <seg>この文書は証明アシスタント |Coq| のリファレンスマニュアルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This error happens generally when:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144303Z" creationid="eldesh" creationdate="20191221T220022Z">
        <seg>このエラーは一般的に起こります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a Reference Manual, so it is not intended for continuous reading.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144930Z" creationid="yamarten" creationdate="20181104T144930Z">
        <seg>この文書はリファレンスマニュアルであり、通読するものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to a regular definition of :token:`ident` followed by the declaration :n:`Canonical Structure @ident`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185018Z" creationid="eldesh" creationdate="20191225T185018Z">
        <seg>これは :token:`ident` の通常の定義に続いて :n:`Canonical Structure @ident` を定義したのと等しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for declaring the implicit type of a single variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T132819Z" creationid="eldesh" creationdate="20191226T132534Z">
        <seg>これは単一の変数の暗黙型を定義するのに有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <note>documentとdocumentationが区別できてないせいでちょっとよろしくない感じになっている。</note>
      <tuv lang="EN-US">
        <seg>This manual does not contain all the documentation the user may need about |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145934Z" creationid="yamarten" creationdate="20181104T145918Z">
        <seg>このマニュアルは |Coq| についてユーザが求める文書が全て含まれているわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <note>http://www.opensource.jp/openpub/ に準拠している。敬体に直した方が自然かもしれない。</note>
      <tuv lang="EN-US">
        <seg>This material (the Coq Reference Manual) may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at http://www.opencontent.org/openpub).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150301Z" creationid="yamarten" creationdate="20181104T150301Z">
        <seg>この作品 (Coq リファレンスマニュアル) はオープン・パブリケーション利用許諾契約書 (v1.0 かそれ以降) で指定された条件と制約に従う限り配布することができる(契約書の最新の版は現在のところ http://www.opencontent.org/openpub/で入手可能である)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message is followed by an explanation of this impossibility.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201627Z" creationid="eldesh" creationdate="20191221T201627Z">
        <seg>このメッセージにはこの不可能性の説明が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntax can also be used for pattern matching.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193922Z" creationid="eldesh" creationdate="20191221T193922Z">
        <seg>この構文はパターンマッチングに使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Through the ``Inductive`` and ``CoInductive`` commands, when the body of the definition is a record declaration of the form ``Build_``\ `R` ``{`` |p_1| ``:`` |t_1|\ ``; … ;`` |p_n| ``:`` |t_n| ``}``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T154716Z" creationid="eldesh" creationdate="20191225T154423Z">
        <seg>``Inductive`` と ``CoInductive`` コマンドを使うのは、定義のボディーが ``Build_``\ `R` ``{`` |p_1| ``:`` |t_1|\ ``; … ;`` |p_n| ``:`` |t_n| ``}`` という形のレコード定義の時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Through the ``Record`` command, in which case the type has to be non-recursive.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T154558Z" creationid="eldesh" creationdate="20191225T145335Z">
        <seg>``Record`` コマンドを使うと、その場合はその型が非再帰的である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the order of the fields is important.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184013Z" creationid="eldesh" creationdate="20191221T184013Z">
        <seg>従ってフィールドの順序は重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the following example cannot be accepted due to the presence of partial application of `wrong` in the body of `wrong` :</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143635Z" creationid="eldesh" creationdate="20191221T215229Z">
        <seg>従って、以下の例は `wrong` のボディー内の `wrong` の部分適用の存在のため受け入れられません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To build an object of type :n:`@ident`, one should provide the constructor :n:`@ident₀` with the appropriate number of terms filling the fields of the record.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191844Z" creationid="eldesh" creationdate="20191221T191844Z">
        <seg>:n:`@ident` 型のオブジェクトを構築するには、レコードのフィールドを埋める適切な数の項を伴った :n:`@ident₀` コンストラクタを提供する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define recursive records, one can use the ``Inductive`` and ``CoInductive`` keywords, resulting in an inductive or co-inductive record.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200647Z" creationid="eldesh" creationdate="20191221T200319Z">
        <seg>再帰的レコードを定義するためには、``Inductive`` と ``CoInductive`` キーワードを使うことができ、結果は帰納的または余帰納的レコードになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ease compatibility with ordinary record types, each primitive projection is also defined as a ordinary constant taking parameters and an object of the record type as arguments, and whose body is an application of the unfolded primitive projection of the same name.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T163624Z" creationid="eldesh" creationdate="20191225T163617Z">
        <seg>通常のレコード型との互換性を緩和するため、各プリミティブ射影は通常のパラメータと、引数としてそのレコード型のオブジェクトとを取り、そのボディーが同じ名前の非畳み込みプリミティブ射影の適用であるものとしても定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To eliminate the (co-)inductive type, one must use its defined primitive projections.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134716Z" creationid="eldesh" creationdate="20191225T134716Z">
        <seg>(余)帰納的型を排除するためには、その定義されたプリミティブ射影を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To start using Coq, it is advised to first read a tutorial.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T034900Z" creationid="yamarten" creationdate="20181007T034900Z">
        <seg>Coqを初めて使う方は、まずチュートリアルを読むことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Turns on the use of primitive projections when defining subsequent records (even through the ``Inductive`` and ``CoInductive`` commands).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160157Z" creationid="eldesh" creationdate="20191225T160157Z">
        <seg>後続のレコードを (``Inductive`` や ``CoInductive`` コマンドだとしても) 定義するときにプリミティブ射影を有効にします。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tutorial</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145951Z" creationid="yamarten" creationdate="20181104T145951Z">
        <seg>チュートリアル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use  the keyword ``Inductive`` or ``CoInductive`` instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202830Z" creationid="eldesh" creationdate="20191221T202820Z">
        <seg>代わりにキーワード ``Inductive`` または ``CoInductive`` を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the :cmd:`Add @table` and :cmd:`Remove @table` commands to update the set of qualids.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193734Z" creationid="eldesh" creationdate="20191221T193734Z">
        <seg>qualid の集合を更新するには :cmd:`Add @table` と :cmd:`Remove @table` コマンドを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User extensions</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150228Z" creationid="yamarten" creationdate="20181104T150228Z">
        <seg>ユーザ拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the so-called *Curry-Howard isomorphism*, programs, properties and proofs are formalized in the same language called *Calculus of Inductive Constructions*, that is a :math:`\lambda`-calculus with a rich type system.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T094032Z" creationid="yamarten" creationdate="20181007T082717Z">
        <seg>*カリー・ハワード同型対応* を使えば、プログラム・性質・証明は全て *Calculus of Inductive Constructions* という一つの言語で表現できます。これは :math:`\lambda` 計算にリッチな型システムが付いたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various informations can be found in the following documents:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145944Z" creationid="yamarten" creationdate="20181104T145944Z">
        <seg>以下の文書からも様々な情報を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe here extensions of |Gallina|’s syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184246Z" creationid="eldesh" creationdate="20191221T184246Z">
        <seg>ここでは |Gallina| の構文の拡張について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We recommend using the various indexes to quickly locate the documentation you are looking for.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144937Z" creationid="yamarten" creationdate="20181104T144937Z">
        <seg>目的の文書を素早く見つけるために、色々な索引を使うことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When `qualid` denotes a projection, the syntax `term.(qualid)` is equivalent to `qualid term`, the syntax `term.(qualid` |arg_1| |arg_n| `)` to `qualid` |arg_1| `…` |arg_n| `term`, and the syntax `term.(@qualid` |term_1| |term_n| `)` to `@qualid` |term_1| `…` |term_n| `term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200620Z" creationid="eldesh" creationdate="20191221T195318Z">
        <seg>`qualid` が射影を意味するとき、`term.(qualid)` という構文は `qualid term` と等しく、`term.(qualid` |arg_1| |arg_n| `)` は `qualid` |arg_1| `…` |arg_n| `term` と、`term.(@qualid` |term_1| |term_n| `)` という構文は `@qualid` |term_1| `…` |term_n| `term` と等しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <note>though の意味が分からん</note>
      <tuv lang="EN-US">
        <seg>When a type is declared with primitive projections, its :g:`match` construct is disabled (see :ref:`primitive_projections` though).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134536Z" creationid="eldesh" creationdate="20191225T134523Z">
        <seg>ある型がプリミティブ射影によって定義されたとき、その :g:`match` による構成は無効化されます (:ref:`primitive_projections` 参照).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the :flag:`Primitive Projections` option is on, definitions of record types change meaning.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134252Z" creationid="eldesh" creationdate="20191225T134252Z">
        <seg>:flag:`Primitive Projections` オプションが有効な時、レコード型の定義は意味を変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override the display format for specified types by adding entries to these tables:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193229Z" creationid="eldesh" creationdate="20191221T193229Z">
        <seg>これらの表にエントリを追加することで特定の型の表示形式を上書きすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``Structure`` is a synonym of the keyword ``Record``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201423Z" creationid="eldesh" creationdate="20191221T201423Z">
        <seg>``Structure`` はキーワード ``Record`` の別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``{measure`` `term` `ident` ``}`` with `ident` being the decreasing argument and `term` being a function from type of `ident` to ``nat`` for which value on the decreasing argument decreases (for the ``lt`` order on ``nat``) at each recursive call of `term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145258Z" creationid="eldesh" creationdate="20191222T134341Z">
        <seg>``{measure`` `term` `ident` ``}`` ここで `ident` は減少する引数であり、`term` は `ident` の型から ``nat`` への関数であり、その減少引数上の値は `term` の再帰呼び出し毎に減少します (``nat`` 上なら ``lt`` 順序に沿って)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``{wf`` `term` `ident` ``}`` with `ident` being the decreasing argument and `term` an ordering relation on the type of `ident` (i.e. of type `T`\ :math:`_{\sf ident}` → `T`\ :math:`_{\sf ident}` → ``Prop``) for which the decreasing argument decreases at each recursive call of `term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134728Z" creationid="eldesh" creationdate="20191222T134728Z">
        <seg>``{wf`` `term` `ident` ``}`` ここで `ident` は減少する引数であり、`term` は `ident` の型上の順序関係 (i.e. `T`\ :math:`_{\sf ident}` → `T`\ :math:`_{\sf ident}` → ``Prop`` という型) であり、その減少引数は `term` の再帰呼び出し毎に減少します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`functional inversion` will not be available for the function.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144547Z" creationid="eldesh" creationdate="20191221T220522Z">
        <seg>その関数についての `functional inversion` が使えるようになりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ident_complete` and `ident_correct` which are inversion information linking the function and its graph.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133355Z" creationid="eldesh" creationdate="20191222T132941Z">
        <seg>`ident_complete` と `ident_correct` は関数とそのグラフを紐付ける反転情報です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ident_rect`, `ident_rec` and `ident_ind`, which reflect the pattern matching structure of `term` (see :cmd:`Inductive`);</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T131331Z" creationid="eldesh" creationdate="20191221T221217Z">
        <seg>`ident_rect` と `ident_rec` と `ident_ind` は `term` (:cmd:`Inductive` 参照) のパターンマッチ構造を反映します;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in which case the correctness of :n:`@type₃` may rely on the instance :n:`@term₂` of :n:`@ident₂` and :n:`@term₂` may in turn depend on :n:`@ident₁`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191007Z" creationid="eldesh" creationdate="20191221T185905Z">
        <seg>この場合 :n:`@type₃` の正しさは :n:`@ident₂` のインスタンスである :n:`@term₂` に依存し、:n:`@term₂` は :n:`@ident₁` に依存するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>manifest) fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T185315Z" creationid="eldesh" creationdate="20191221T185315Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>than like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143311Z" creationid="eldesh" creationdate="20191221T214431Z">
        <seg>これより良いでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the definition is not a *pattern matching tree* as explained above.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144855Z" creationid="eldesh" creationdate="20191221T220305Z">
        <seg>その定義は上で説明したような *パターンマッチングツリー* ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the definition uses pattern matching on dependent types, which ``Function`` cannot deal with yet.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144335Z" creationid="eldesh" creationdate="20191221T220124Z">
        <seg>その定義は依存型上のパターンマッチを使っており、``Function`` はまだそれを扱うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the first identifier :token:`ident` is the name of the defined record and :token:`sort` is its type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T171245Z" creationid="eldesh" creationdate="20191221T171245Z">
        <seg>最初の識別子 :token:`ident` は定義されたレコードの名前であり、:token:`sort` はその型です。</seg>
      </tuv>
    </tu>
    <tu>
      <note>意図がちゃんとわかってない。「型検査器であり、証明アシスタントでもある」「証明アシスタントではタクティックというものを使う」の2点か？そもそもタクティックを言語と呼ぶのに違和感があるので、先を見てから戻ってきたい。</note>
      <tuv lang="EN-US">
        <seg>|Coq| also provides an interactive proof assistant to build proofs using specific programs called *tactics*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T112633Z" creationid="yamarten" creationdate="20181007T101451Z">
        <seg>また、|Coq| は、 *タクティック* と呼ばれるプログラムを用いて証明を構築する、対話的証明アシスタントも提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|Gallina| is the kernel language of |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184208Z" creationid="eldesh" creationdate="20191221T184208Z">
        <seg>|Gallina| は |Coq| の核言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <note>term_0 とは</note>
      <tuv lang="EN-US">
        <seg>|term_0| must be built as a *pure pattern matching tree* (:g:`match … with`) with applications only *at the end* of each branch.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143345Z" creationid="eldesh" creationdate="20191221T214806Z">
        <seg>|term_0| は 各ブランチの *末尾* のみで適用される *純粋パターンマッチングツリー* (:g:`match … with`) として構築されなければなりません。</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>

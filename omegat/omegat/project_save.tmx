<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.3.1_0_99222d65" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>*Limitations*</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T214708Z" creationid="eldesh" creationdate="20191221T214708Z">
        <seg>*制限*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 is the default level.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T205330Z" creationid="eldesh" creationdate="20200106T205330Z">
        <seg>1 はデフォルトレベルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2 shows additional information such as tried tactics and shelving of goals.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T205435Z" creationid="eldesh" creationdate="20200106T205435Z">
        <seg>2 は追加の情報を表示します。例えばタクティックやゴールの先送りなどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:ref:`functional-scheme` and :tacn:`function induction`</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T220621Z" creationid="eldesh" creationdate="20191221T220621Z">
        <seg>:ref:`functional-scheme` と :tacn:`function induction`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:ref:`thecoqcommands`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145020Z" creationid="yamarten" creationdate="20181104T145020Z">
        <seg>:ref:`thecoqcommands`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@binders } : @sort := @ident₀ {?</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191507Z" creationid="eldesh" creationdate="20191221T191507Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@binders }`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191456Z" creationid="eldesh" creationdate="20191221T191456Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A *caveat*, however, is that records cannot appear in mutually inductive (or co-inductive) definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201335Z" creationid="eldesh" creationdate="20191221T200543Z">
        <seg>注意点として、しかしながら、レコードは相互帰納的 (または余帰納的) 定義の中に現れることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A *class* is either a sort (denoted by the keyword ``Sortclass``), a product type (denoted by the keyword ``Funclass``), or a type constructor (denoted by its name), e.g. an inductive type or any constant with a type of the form ``forall (`` |x_1| : |A_1| ) … ``(``\ |x_n| : |A_n|\ ``)``, `s` where `s` is a sort.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T170318Z" creationid="eldesh" creationdate="20191226T170318Z">
        <seg>*クラス* はソート (``Sortclass`` キーワードで表現される) か、積型 (``Funclass`` キーワードで表現される) か、または型構築子 (その名前で表現される) のいずれかであり、例えば、帰納型や ``forall (`` |x_1| : |A_1| ) … ``(``\ |x_n| : |A_n|\ ``)``, `s` ここで `s` はソートであるような形式の型を伴う任意の定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A canonical structure is an instance of a record/structure type that can be used to solve unification problems involving a projection applied to an unknown structure instance (an implicit argument) and a value.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T182609Z" creationid="eldesh" creationdate="20191225T182543Z">
        <seg>正準構造とはレコードまたはストラクチャ型のインスタンスの一つであり、それを未知のストラクチャインスタンス (暗黙引数) と値に射影を実行することで単一化問題を解くのに使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A commented version of sources of the |Coq| standard library (including only the specifications, the proofs are removed) is available at https://coq.inria.fr/stdlib/.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150204Z" creationid="yamarten" creationdate="20181104T150204Z">
        <seg>|Coq| 標準ライブラリのコメント付きソースコード (仕様のみで、証明を省いたもの)は https://coq.inria.fr/stdlib/ で閲覧できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A companion volume to this reference manual, the |Coq| Tutorial, is aimed at gently introducing new users to developing proofs in |Coq| without assuming prior knowledge of type theory.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145957Z" creationid="yamarten" creationdate="20181104T145957Z">
        <seg>このマニュアルと対を成す |Coq| チュートリアルは、新規ユーザが型理論の知識なしに |Coq| で証明を構築できるようになるまで、優しく導入することを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more precise description is given below.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T131250Z" creationid="eldesh" creationdate="20191221T220812Z">
        <seg>より詳細な説明を以下で与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A text file `INSTALL` that comes with the sources explains how to install |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150123Z" creationid="yamarten" creationdate="20181104T150123Z">
        <seg>ソースに付属するテキストファイル `INSTALL` では、 |Coq| をインストールする方法について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Addendum</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150239Z" creationid="yamarten" creationdate="20181104T150239Z">
        <seg>付録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, user-written :g:`match` constructs on primitive records are desugared into substitution of the projections, they cannot be printed back as :g:`match` constructs.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T164515Z" creationid="eldesh" creationdate="20191225T164515Z">
        <seg>さらに、プリミティブレコード上のユーザ記述の :g:`match` は射影の代入への脱糖され、それらは :g:`match` として表示することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adds blocks of implicit types with different specifications.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T132934Z" creationid="eldesh" creationdate="20191226T132934Z">
        <seg>異なる仕様を伴った暗黙型のブロックを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advanced recursive functions</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T212337Z" creationid="eldesh" creationdate="20191221T212337Z">
        <seg>高度な再帰関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again one has to tell |Coq| that the type ``nat`` is in the ``LEQ`` class, and how the type constructor ``*`` interacts with the ``LEQ`` class.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T160204Z" creationid="eldesh" creationdate="20200102T160204Z">
        <seg>この場合も |Coq| に ``nat`` 型が ``LEQ`` クラスに属していること、そして型コンストラクタ ``*`` が ``LEQ`` クラスとどのように相互作用するのかを伝える必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, for all the details the reader can refer to :cite:`CSwcu`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T220128Z" creationid="eldesh" creationdate="20200102T220128Z">
        <seg>繰り替えしますが、全ての詳細について :cite:`CSwcu` が読者の参考になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All in all, the only new piece of information we add in the ``LEQ`` class is the mixin, all the rest is already canonical for ``T`` and hence can be inferred by |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T213915Z" creationid="eldesh" creationdate="20200102T213700Z">
        <seg>結局のところ、我々が ``LEQ`` クラスに新たに追加した情報の断片は mixin だけであり、残りの全ては既に ``T`` について正準であり、従って |Coq| により推論することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All logical judgments in |Coq| are typing judgments.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T101610Z" creationid="yamarten" creationdate="20181007T100201Z">
        <seg>|Coq| における論理的判断は全て型付け判断です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All services of the |Coq| proof assistant are accessible by interpretation of a command language called *the vernacular*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144825Z" creationid="yamarten" creationdate="20181007T112922Z">
        <seg>|Coq| が提供する全てのサービスは、 *Vernacular* と呼ばれるコマンド言語を読み込ませることで利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All variables are candidate for generalization if they appear free in the context under a generalization delimiter.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T161903Z" creationid="eldesh" creationdate="20191226T141710Z">
        <seg>全ての変数は一般化デリミタの中の文脈で自由に出現するならば一般化の候補になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allow generalization of the given identifiers only.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T143411Z" creationid="eldesh" creationdate="20191226T143411Z">
        <seg>与えられた識別子のみについて一般化を許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allows exporting the choice of generalizable variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T143543Z" creationid="eldesh" creationdate="20191226T143543Z">
        <seg>一般化可能変数についての選択をエクスポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the following syntax allows creating objects by using named fields, as shown in this grammar.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T192325Z" creationid="eldesh" creationdate="20191221T192325Z">
        <seg>この文法で示されるように、代わりに以下の構文で名前付きフィールドを使うことでオブジェクトを作ることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative syntax for projections based on a dot notation is available:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194622Z" creationid="eldesh" creationdate="20191221T194622Z">
        <seg>射影のためドット記法に基づいた代替構文が使用可能です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An arbitrary context of ``binders`` can be put after the name of the instance and before the colon to declare a parameterized instance.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T181934Z" creationid="eldesh" creationdate="20200103T194627Z">
        <seg>パラメータ化されたインスタンスを宣言するためにインスタンスの名前の後かつコロンの前に ``binders`` の任意の文脈を置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example implementation is:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T140632Z" creationid="eldesh" creationdate="20200103T140632Z">
        <seg>実装例は:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional priority can be declared, 0 being the highest priority as for :tacn:`auto` hints.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T182023Z" creationid="eldesh" creationdate="20200103T195111Z">
        <seg>任意に優先度を宣言することが出来、:tacn:`auto` ヒントのためのもののように 0 が最高優先度です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unfolded primitive projection application obeys the rule above, while the folded version delta-reduces to the unfolded version.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160741Z" creationid="eldesh" creationdate="20191225T160541Z">
        <seg>非畳み込みプリミティブ射影適用は上の規則にしたがい、一方畳み込み版は非畳み込み版へデルタ簡約します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And we enable |Coq| to relate pair of terms with ``&lt;=``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T134518Z" creationid="eldesh" creationdate="20191228T145200Z">
        <seg>そして |Coq| に項のペアを ``&lt;=`` によって関連付けさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any argument not given as part of a typeclass binder will be automatically generalized.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T223800Z" creationid="eldesh" creationdate="20200103T151443Z">
        <seg>型クラスの束縛子の一部として与えられなかった引数も自動的に一般化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As before we register a canonical ``LE`` class for ``nat``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191228T145102Z" creationid="eldesh" creationdate="20191228T145057Z">
        <seg>これまでのように ``nat`` のために正準 ``LE`` クラスを登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>class subgoal とは？</note>
      <tuv lang="EN-US">
        <seg>As of Coq 8.6, ``all:once (typeclasses eauto)`` faithfully mimicks what happens during typeclass resolution when it is called during refinement/type inference, except that *only* declared class subgoals are considered at the start of resolution during type inference, while ``all`` can select non-class subgoals as well.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T190612Z" creationid="eldesh" creationdate="20200103T210850Z">
        <seg>Coq 8.6 を基点として、 ``all:once (typeclasses eauto)`` は宣言されたクラスサブゴール *だけ* が型推論中に解消の開始と考えられる場合を除き、精細化/型推論の間にそれが呼ばれたとき型クラス解決の間に何が起きるかを忠実に模倣し、一方 ``all`` は非クラスサブゴールを選択できる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we have seen, ``Ord`` is encoded as a record type with two parameters: a type ``A`` and an ``E`` of type ``EqDec A``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T172715Z" creationid="eldesh" creationdate="20200103T172715Z">
        <seg>見てきたように、``Ord`` は二つのパラメータ: ``A`` 型と ``EqDec A`` 型の ``E`` を持つレコードとして符号化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assia Mahboubi and Enrico Tassi</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T104533Z" creationid="eldesh" creationdate="20191227T104533Z">
        <seg>Assia Mahboubi and Enrico Tassi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assume that :token:`qualid` denotes an object ``(Build_struct`` |c_1| … |c_n| ``)`` in the structure :g:`struct` of which the fields are |x_1|, …, |x_n|.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T183129Z" creationid="eldesh" creationdate="20191225T183129Z">
        <seg>:token:`qualid` がフィールドが |x_1|, …, |x_n| であるような構造 :g:`struct` の中のあるオブジェクト ``(Build_struct`` |c_1| … |c_n| ``)`` を示すと仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the current stage we can use ``==`` and ``&lt;=`` on concrete types, like tuples of natural numbers, but we can’t develop an algebraic theory over the types that are equipped with both relations.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191229T130928Z" creationid="eldesh" creationdate="20191229T130928Z">
        <seg>現段階では我々は自然数の組のような具体型の上で ``==`` と ``&lt;=`` を使うことができますが、両方の関係を備えた型上の代数的理論を開発することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authors</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T104605Z" creationid="eldesh" creationdate="20191227T104605Z">
        <seg>著者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic generation of induction schemes for non-recursive records defined with the ``Record`` keyword can be activated with the ``Nonrecursive Elimination Schemes`` option (see :ref:`proofschemes-induction-principles`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201328Z" creationid="eldesh" creationdate="20191221T201328Z">
        <seg>``Record`` キーワードによって定義された非-再帰的レコードの帰納スキームの自動生成は ``Nonrecursive Elimination Schemes`` オプション (:ref:`proofschemes-induction-principles` 参照) によって有効化することができる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the :cmd:`Class` and :cmd:`Instance` vernacular commands, there are a few other commands related to typeclasses.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T202528Z" creationid="eldesh" creationdate="20200103T202528Z">
        <seg>:cmd:`Class` と :cmd:`Instance` Vernacular コマンドの他に、型クラスに関連するコマンドがいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binding classes</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T144116Z" creationid="eldesh" creationdate="20200103T144116Z">
        <seg>クラスの束縛</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Building hierarchies</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T171300Z" creationid="eldesh" creationdate="20200103T171300Z">
        <seg>階層の構築</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, all constants and local variables are considered transparent.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T190439Z" creationid="eldesh" creationdate="20200106T190439Z">
        <seg>デフォルトでは、全ての定数と局所変数は透明とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, if no limit is given, the search is unbounded.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T212319Z" creationid="eldesh" creationdate="20200103T212319Z">
        <seg>デフォルトでは、制限が与えられないならば検索は制限されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calculus of Inductive Constructions</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181110T055945Z" creationid="yamarten" creationdate="20181110T055945Z">
        <seg>Calculus of Inductive Constructions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this command multiple times adds to the allowed identifiers.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T143455Z" creationid="eldesh" creationdate="20191226T143455Z">
        <seg>このコマンドの複数回呼ぶと許可された識別子へ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Canonical Structures</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T104306Z" creationid="eldesh" creationdate="20191227T104306Z">
        <seg>正準構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Canonical structures</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T182327Z" creationid="eldesh" creationdate="20191225T182327Z">
        <seg>正準構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Canonical structures are particularly useful when mixed with coercions and strict implicit arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T184259Z" creationid="eldesh" creationdate="20191225T184259Z">
        <seg>正準構造は型強制と厳密暗黙引数と混用したときに特に有用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapters :ref:`gallinaspecificationlanguage` and :ref:`extensionsofgallina` describe the concrete syntax as well as the meaning of programs, theorems and proofs in the Calculus of Inductive Constructions.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145106Z" creationid="yamarten" creationdate="20181104T145106Z">
        <seg>:ref:`gallinaspecificationlanguage` および :ref:`extensionsofgallina` の章では、構文および Calculus of Inductive Constructions におけるプログラムや証明・定理の意味について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`calculusofinductiveconstructions` is a mathematical description of the formalism.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145128Z" creationid="yamarten" creationdate="20181104T145128Z">
        <seg>:ref:`calculusofinductiveconstructions` の章は数学の形式的な説明です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`thecoqlibrary` describes the standard library of |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145114Z" creationid="yamarten" creationdate="20181104T145114Z">
        <seg>:ref:`thecoqlibrary` の章では |Coq| の標準ライブラリについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`themodulesystem` describes the module system.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145130Z" creationid="yamarten" creationdate="20181104T145130Z">
        <seg>:ref:`themodulesystem` の章ではモジュールシステムについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>"requests to the environment"が指すものがわかっていない。環境ってどの辺りなんだろう。宣言とかの話なのか、Setみたいなより広い話を含んでいるのか。</note>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`vernacularcommands` presents all commands (we call them *vernacular commands*) that are not directly related to interactive proving: requests to the environment, complete or partial evaluation, loading and compiling files.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145429Z" creationid="yamarten" creationdate="20181104T145429Z">
        <seg>:ref:`vernacularcommands` の章では、対話的証明と直接的には関係のないコマンド (*Vernacular コマンド*) を全て挙げます。コマンドは、環境への要求、完全/部分的な評価、ファイルの読み込みやコンパイルなどを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class and Instance declarations</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T211518Z" creationid="eldesh" creationdate="20200103T135632Z">
        <seg>クラスとインスタンスの宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercions</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T165158Z" creationid="eldesh" creationdate="20191226T165158Z">
        <seg>コアーション</seg>
      </tuv>
    </tu>
    <tu>
      <note>the chapter とは？</note>
      <tuv lang="EN-US">
        <seg>Coercions and records in section :ref:`coercions-classes-as-records` of the chapter devoted to coercions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T205044Z" creationid="eldesh" creationdate="20191221T204147Z">
        <seg>そのチャプターのセクション :ref:`coercions-classes-as-records` のコアーションとレコードはコアーションに費やされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercions can be used to implicitly inject terms from one *class* in which they reside into another one.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T165810Z" creationid="eldesh" creationdate="20191226T165810Z">
        <seg>コアーションは項をそれが属するある一つの *クラス* からもう一つのそれに暗黙的に埋め込むのに使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coercions, implicit arguments, the type of pattern matching, but also notations (see :ref:`syntaxextensionsandinterpretationscopes`) can obfuscate the behavior of some tactics (typically the tactics applying to occurrences of subterms are sensitive to the implicit arguments).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T101821Z" creationid="eldesh" creationdate="20191226T190743Z">
        <seg>コアーション、暗黙引数、パターンマッチングの型、そればかりでなく表記法 (:ref:`syntaxextensionsandinterpretationscopes` 参照) もいくつかのタクティックの振る舞いを分かりにくくし得ます (典型的には部分項の出現に適用するタクティックは暗黙引数に対して敏感です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compact declaration of Canonical Structures</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T203613Z" creationid="eldesh" creationdate="20200102T203613Z">
        <seg>正準構造のコンパクトな定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compatibility Projections and :g:`match`</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T162633Z" creationid="eldesh" creationdate="20191225T162633Z">
        <seg>互換性射影と :g:`match`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contrary to :tacn:`auto`, introduction steps are counted, which might result in larger limits being necessary when searching with ``typeclasses eauto`` than with :tacn:`auto`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T192404Z" creationid="eldesh" creationdate="20200103T212438Z">
        <seg>:tacn:`auto` と異なり、導入ステップは数えられ、その結果として :tacn:`auto` より ``typeclasses eauto`` による検索の時はより大きい制限が必要とされるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contrary to :tacn:`eauto` and :tacn:`auto`, the resolution is done entirely in the new proof engine (as of Coq 8.6), meaning that backtracking is available among dependent subgoals, and shelving goals is supported.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T203944Z" creationid="eldesh" creationdate="20200103T203814Z">
        <seg>:tacn:`eauto` や :tacn:`auto` と逆に、(Coq 8.6 を基点として) 新しい証明エンジンの中で全体が完了します、依存サブゴールの中でバックトラッキングが可能で、かつゴールの見送りがサポートされていることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contrary to Haskell, we have no special syntax for superclasses, but this declaration is equivalent to:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T224901Z" creationid="eldesh" creationdate="20200103T172052Z">
        <seg>Haskell と違い、スーパークラスのために特別な構文はありませんが、この宣言は以下と等しくなります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls whether typeclass resolution steps are shown during search.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T205048Z" creationid="eldesh" creationdate="20200106T205048Z">
        <seg>型クラス解決のステップが検索中に表示されるかどうかを制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>唐突に「Coq」から外れる縦棒。どうも付けるとsmallcapクラスが付くっぽいのだけど、スモールキャピタルにはなっているわけでもなく、特に意味は無さそう。
</note>
      <tuv lang="EN-US">
        <seg>Coq has an interactive mode in which commands are interpreted as the user types them in from the keyboard and a compiled mode where commands are processed from a file.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T114048Z" creationid="yamarten" creationdate="20181007T113510Z">
        <seg>Coq には、ユーザが入力した端からコマンドを実行していく対話モードと、ファイルに書かれたコマンドを順に実行していくコンパイルモードがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declares variables according to the given binding context, which might use :ref:`implicit-generalization`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T185016Z" creationid="eldesh" creationdate="20200103T203306Z">
        <seg>与えられた束縛コンテキストに従って変数を宣言します。それは :ref:`implicit-generalization` を使うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines a recursive function by well-founded recursion.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133844Z" creationid="eldesh" creationdate="20191222T133844Z">
        <seg>整礎再帰によって再帰関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines the not recursive function `ident` as if declared with `Definition`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T131308Z" creationid="eldesh" creationdate="20191221T221023Z">
        <seg>非-再帰関数 `ident` をあたかも `Definition` によって定義されたかのように定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defines the structural recursive function `ident` as if declared with ``Fixpoint``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133514Z" creationid="eldesh" creationdate="20191222T133514Z">
        <seg>構造的再帰関数 `ident` を ``Fixpoint`` により定義されたかのように定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Definitional classes are not wrapped inside records, and the trivial projection of an instance of such a class is convertible to the instance itself.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T192742Z" creationid="eldesh" creationdate="20200103T192730Z">
        <seg>定義クラスはレコードの中に包まれておらず、そのようなクラスのインスタンスの自明な射影はそのインスタンスそれ自身と変換できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dependent subgoals are automatically shelved, and shelved goals can remain after resolution ends (following the behavior of Coq 8.5).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T205657Z" creationid="eldesh" creationdate="20200103T204659Z">
        <seg>依存サブゴールは自動的に先送りにされ、先送りされたゴールは (Coq 8.5 の振る舞いに従うと) 解消終了の後まで残ることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the ``{…}`` annotation, different definition mechanisms are used by ``Function``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144640Z" creationid="eldesh" creationdate="20191221T220752Z">
        <seg>``{…}`` という注釈に依存して、``Function`` によって異なる定義機構が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the annotation, the user is left with some proof obligations that will be used to define the function.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145620Z" creationid="eldesh" creationdate="20191222T135037Z">
        <seg>注釈に依存して、その関数を定義するのに使われるいくらかの証明課題はユーザに残されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Derived Canonical Structures</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T122037Z" creationid="eldesh" creationdate="20191227T122037Z">
        <seg>派生した正準構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Determines how much information is shown for typeclass resolution steps during search.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T205316Z" creationid="eldesh" creationdate="20200106T205316Z">
        <seg>どれくらいの情報が型クラス解決のステップが検索中に表示されるかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disable implicit generalization  entirely.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T143335Z" creationid="eldesh" creationdate="20191226T143335Z">
        <seg>暗黙の一般化を完全に無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the definition of the one-constructor inductive definition, all the errors of inductive definitions, as described in Section :ref:`gallina-inductive-definitions`, may also occur.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T203528Z" creationid="eldesh" creationdate="20191221T203528Z">
        <seg>コンストラクタが一つの帰納的定義を定義しているとき、セクション :ref:`gallina-inductive-definitions` で説明される帰納的定義の全てのエラーも起こる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <note>型がインスタンス化とは？</note>
      <tuv lang="EN-US">
        <seg>Each class definition gives rise to a corresponding record declaration and each instance is a regular definition whose name is given by ident and type is an instantiation of the record type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T215050Z" creationid="eldesh" creationdate="20200104T212439Z">
        <seg>各クラス定義は対応するレコード宣言を生みだし、各インスタンスは標準の定義でありその名前は ident で与えられ、その型はレコード型のインスタンス化です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error messages are also quite intelligible (if one skips to the end of the message).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T220756Z" creationid="eldesh" creationdate="20200102T220756Z">
        <seg>エラーメッセージも非常に理解しやすいです (メッセージの末尾まで飛ばすなら)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Eta-conversion allows to define dependent elimination for these types as well.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T145640Z" creationid="eldesh" creationdate="20191225T145640Z">
        <seg>その上、Eta 変換はこれらの型について依存除去を定義することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if the record type has parameters, these do not appear at applications of the projection, considerably reducing the sizes of terms when manipulating parameterized records and type checking time.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T133448Z" creationid="eldesh" creationdate="20191225T133448Z">
        <seg>そのレコード型がパラメータを持っていたとしても、これらは射影の適用には現れず、パラメータ化されたレコードを操作するときの項のサイズや型検査時間を大幅に減少させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of tactics are described in Chapter :ref:`detailedexamplesoftactics`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145621Z" creationid="yamarten" creationdate="20181104T145621Z">
        <seg>タクティックの具体例は :ref:`detailedexamplesoftactics` の章で説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions of |Gallina|</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184133Z" creationid="eldesh" creationdate="20191221T184133Z">
        <seg>|Gallina| の拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, :token:`binders` are parameters of the record.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184039Z" creationid="eldesh" creationdate="20191221T184039Z">
        <seg>最後に、:token:`binders` はレコードのパラメータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Chapter :ref:`coqintegrateddevelopmentenvironment` describes CoqIDE.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145816Z" creationid="yamarten" creationdate="20181104T145816Z">
        <seg>最後に、 :ref:`coqintegrateddevelopmentenvironment` の章で、 CoqIDE について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the |SSR| proof language is presented in Chapter :ref:`thessreflectprooflanguage`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145630Z" creationid="yamarten" creationdate="20181104T145630Z">
        <seg>最後に、証明言語 |SSR| について :ref:`thessreflectprooflanguage` の章で説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>compile mode じゃなかったのかよ。</note>
      <tuv lang="EN-US">
        <seg>First in Chapter :ref:`thecoqcommands`, the usage of `coqc` (batch mode) and `coqtop` (interactive mode) with their options is described.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145714Z" creationid="yamarten" creationdate="20181104T145714Z">
        <seg>まず、 :ref:`thecoqcommands` の章で、`coqc` (コンパイルモード) と `coqtop` (対話モード) の使い方およびオプションについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First the macro generates a variant type definition with just one constructor: :n:`Variant @ident {?</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191437Z" creationid="eldesh" creationdate="20191221T191223Z">
        <seg>まずマクロは高々一つのコンストラクタをもつバリアント型定義を生成します: :n:`Variant @ident { @binders } : @sort := @ident₀ { @binders }` 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Following the previous example, one can write:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T152854Z" creationid="eldesh" creationdate="20200103T152854Z">
        <seg>以前の例に続き、次のように書くことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a given field :token:`ident`, its type is :g:`forall binders, type`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183456Z" creationid="eldesh" creationdate="20191221T183448Z">
        <seg>あるフィールド :token:`ident` が与えられた場合、その型は :g:`forall binders, type` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an actual introduction to typeclasses, there is a description of the system :cite:`sozeau08` and the literature on type classes in Haskell which also applies.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T211337Z" creationid="eldesh" creationdate="20200103T135608Z">
        <seg>実質的な型クラスの導入に付いてはシステムについての説明が :cite:`sozeau08` にあることに加え Haskell での型クラスについての論文も応用することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For compatibility, the parameters still appear to the user when printing terms even though they are absent in the actual AST manipulated by the kernel.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T144549Z" creationid="eldesh" creationdate="20191225T144549Z">
        <seg>互換性のため、カーネルにより操作された実際のAST中には存在しないものであっても項を表示する時にパラメータはユーザに表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each of them, the canonical structure of which it is a projection is indicated.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185241Z" creationid="eldesh" creationdate="20191225T185208Z">
        <seg>それぞれについて、その正準構造が射影であるということを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example it is better to define plus like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143302Z" creationid="eldesh" creationdate="20191221T214351Z">
        <seg>例えば plus はこのように定義した方が:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, forcing a constant to explicitely appear in the pattern will make it never apply on a goal where there is a hole in that place.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T195739Z" creationid="eldesh" creationdate="20200106T195739Z">
        <seg>例えばある定数を、その場所にホールがあるゴール上でけっして適用させないパターン中に明示的に出現することを強制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T161832Z" creationid="eldesh" creationdate="20200103T161832Z">
        <seg>例えば:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the above example gives the following output:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185236Z" creationid="eldesh" creationdate="20191225T185236Z">
        <seg>例えば、上の例は以下の出力を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, we might have: :n:`Record @ident @binders : @sort := { @ident₁ : @type₁ ; @ident₂ := @term₂ ; @ident₃ : @type₃ }`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T190954Z" creationid="eldesh" creationdate="20191221T185415Z">
        <seg>例えば、:n:`Record @ident @binders : @sort := { @ident₁ : @type₁ ; @ident₂ := @term₂ ; @ident₃ : @type₃ }` があるとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For now, dependent cases are not treated for non structurally terminating functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143648Z" creationid="eldesh" creationdate="20191221T215336Z">
        <seg>今のところ、依存ケースは非-構造的停止関数として扱われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function does not support partial application of the function being defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143555Z" creationid="eldesh" creationdate="20191221T215107Z">
        <seg>Function は定義された関数の部分適用はサポートしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further compatibility printing can be deactivated thanks to the ``Printing Primitive Projection Compatibility`` option which governs the printing of pattern matching over primitive records.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T144857Z" creationid="eldesh" creationdate="20191225T144857Z">
        <seg>さらなる互換表示は ``Printing Primitive Projection Compatibility`` オプションで非有効化することができ、これはプリミティブレコード上のパターンマッチを抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence the example can also be written:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T145435Z" creationid="eldesh" creationdate="20200103T145435Z">
        <seg>従ってこの例は以下のようにも書くことが出来ます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here ``A`` is implicitly generalized, and the resulting function is equivalent to the one above.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T153042Z" creationid="eldesh" creationdate="20200103T153042Z">
        <seg>ここでは ``A`` は暗黙的に一般化され、結果の関数は上のそれに等しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T184307Z" creationid="eldesh" creationdate="20191225T184307Z">
        <seg>これが例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the Global modifier redeclares the instance at the end of the section, once it has been generalized by the context variables it uses.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T224715Z" creationid="eldesh" creationdate="20200103T163942Z">
        <seg>ここで Global 修飾子はセクションの終わりで、かつてそれが使う文脈変数により一般化されていたインスタンスを再宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here we show how to deal with type constructors, i.e. how to make the following example work:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T122234Z" creationid="eldesh" creationdate="20191227T122234Z">
        <seg>ここでは型コンストラクタをどのように扱うか、つまり以下の例がどのように動作するかを示します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hierarchy of structures</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191228T140940Z" creationid="eldesh" creationdate="20191228T140940Z">
        <seg>構造の階層</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to read this book</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144922Z" creationid="yamarten" creationdate="20181104T144922Z">
        <seg>この文書の読み方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to start and stop proofs, do multiple proofs in parallel is explained in Chapter :ref:`proofhandling`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145435Z" creationid="yamarten" creationdate="20181104T145435Z">
        <seg>どのように証明を始め、終わればいいのか、どうすれば証明を並行して進めることができるかは、 :ref:`proofhandling` の章で説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, one can still use it as if it had a single parameter inside generalizing binders: the generalization of superclasses will be done automatically.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T225819Z" creationid="eldesh" creationdate="20200103T174026Z">
        <seg>しかし、それでもそれを一般化束縛子の中で単一パラメータを持つかのように使うことができます: スーパークラスの一般化は自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the generalizing binders should be used instead as they have particular support for typeclasses:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T145940Z" creationid="eldesh" creationdate="20200103T145858Z">
        <seg>しかしながら、替わりに型クラスの特別なサポートを持った束縛子の一般化を使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this feature does not work for non structurally recursive functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T213839Z" creationid="eldesh" creationdate="20191221T213839Z">
        <seg>しかし、この帰納は非-構造的再帰関数については動きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, to take the :math:`{\delta}` flag into account, projections can be in two states: folded or unfolded.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160629Z" creationid="eldesh" creationdate="20191225T160438Z">
        <seg>しかし、:math:`{\delta}` フラグを考慮すると、射影は 畳み込み または 非畳み込み という二つの状態になり得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If :token:`sort` is omitted, the default sort is `\Type`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183210Z" creationid="eldesh" creationdate="20191221T183103Z">
        <seg>:token:`sort` が省略された場合は、デフォルトのソートは `\Type` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If `string` ends in ``.dot`` or ``.gv``, the constraints are printed in the DOT language, and can be processed by Graphviz tools.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T101321Z" creationid="eldesh" creationdate="20191227T101321Z">
        <seg>`string` が ``.dot`` や ``.gv`` で終わっていたら、制約がDOT言語で出力され、Graphviz ツールで処理できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a field is named `_` then no projection is built for it.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194250Z" creationid="eldesh" creationdate="20191221T194250Z">
        <seg>もしフィールドの名前が `_` ならばそれのための射影は構築されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a same field occurs in several canonical structures, then only the structure declared first as canonical is considered.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185258Z" creationid="eldesh" creationdate="20191225T184830Z">
        <seg>いくつかの正準構造に同じフィールドが現れた場合は、初めに定義された構造のみが正準と認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is omitted, the default name ``Build_``\ :token:`ident`, where :token:`ident` is the record name, is used.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183052Z" creationid="eldesh" creationdate="20191221T183052Z">
        <seg>それが省略された場合、デフォルトの名称である ``Build_``\ :token:`ident` ここで :token:`ident` はレコード名、が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>inhabitantsとは？</note>
      <tuv lang="EN-US">
        <seg>If one does not give all the members in the Instance declaration, Coq enters the proof-mode and the user is asked to build inhabitants of the remaining fields, e.g.:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T221417Z" creationid="eldesh" creationdate="20200103T141932Z">
        <seg>インスタンス宣言の中で全てのメンバを与えない場合、Coq は証明モードに入りユーザが残りのフィールドの住民の構築を要求されます。例えば:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If set, use the record syntax (shown above) as the default display format.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193126Z" creationid="eldesh" creationdate="20191221T193126Z">
        <seg>セットすると、レコード構文 (上記) をデフォルト表示形式として使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional ``Sorted`` option is given, each universe will be made equivalent to a numbered label reflecting its level (with a linear ordering) in the universe hierarchy.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T101123Z" creationid="eldesh" creationdate="20191226T200220Z">
        <seg>オプショナルな ``Sorted`` オプションが与えられると、各ユニバースは宇宙の階層内での (線形順序付けによる) レベルを反映した番号付きラベルに相当するようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the priority is not specified, it defaults to the number of non-dependent binders of the instance.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T182203Z" creationid="eldesh" creationdate="20200103T195222Z">
        <seg>優先度が指定されないならば、デフォルトのそのインスタンスの非依存束縛子の数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit generalization</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T134148Z" creationid="eldesh" creationdate="20191226T134148Z">
        <seg>暗黙の一般化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit generalization is an automatic elaboration of a statement with free variables into a closed statement where these variables are quantified explicitly.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T134325Z" creationid="eldesh" creationdate="20191226T134325Z">
        <seg>暗黙の一般化とは自由変数を伴う式をこれらの変数が明示的に量化された閉じた文への自動的な詳細化です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit generalization is done inside binders starting with a \` and terms delimited by \`{ } and \`( ), always introducing maximally inserted implicit arguments for the generalized variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T160438Z" creationid="eldesh" creationdate="20191226T134823Z">
        <seg>暗黙の一般化は \` から始まる束縛子と \`{ } と \`( ) で区切られている項の中で行われ、一般化された変数について常に最大限に暗黙引数が挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit types of variables</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T131740Z" creationid="eldesh" creationdate="20191226T131740Z">
        <seg>変数の暗黙の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter :ref:`tactics`, all commands that realize one or more steps of the proof are presented: we call them *tactics*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145557Z" creationid="yamarten" creationdate="20181104T145557Z">
        <seg>:ref:`tactics` の章では、証明の1つまたは複数のステップを成すコマンド (*タクティック*) を全て挙げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a Module Type, this command states that a corresponding concrete instance should exist in any implementation of this Module Type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T183722Z" creationid="eldesh" creationdate="20200103T201606Z">
        <seg>このコマンドはあるモジュール型の中で、対応する具体的なインスタンスがこのモジュール型で何らかの実装として存在するべきだということを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>とっくの昔に消えているような気がする。</note>
      <tuv lang="EN-US">
        <seg>In a second step, the user can read also the tutorial on recursive types (document `RecTutorial.ps`).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150007Z" creationid="yamarten" creationdate="20181104T150007Z">
        <seg>その後は、再帰型についてのチュートリアル (`RecTutorial.ps`) を読むのもいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case no satisfying constraint can be found, an error is raised:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T144628Z" creationid="eldesh" creationdate="20200103T144628Z">
        <seg>制約を充足するものが見つからない場合は、エラーが起きます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each case, `term` is the object projected and the other arguments are the parameters of the inductive type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200629Z" creationid="eldesh" creationdate="20191221T195516Z">
        <seg>いずれの場合も、`term` は射影されたオブジェクトであり、他の引数は帰納型のパラメータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, the :cmd:`Record` macro is more general than the usual record types, since it allows also for “manifest” expressions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T165910Z" creationid="eldesh" creationdate="20191221T165600Z">
        <seg>実際は、:cmd:`Record` マクロは普通のレコード型より一般的であり、”マニフェスト” 式のためのものでもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In interactive mode, users can develop their theories and proofs step by step, and query the system for available theorems and definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T122200Z" creationid="yamarten" creationdate="20181007T122200Z">
        <seg>対話モードでは、ユーザは順を追って証明を構築したり、利用できる定理や定義をシステムに問い合わせたりできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words |Coq| does not see that an object of the ``LEQ`` class is also an object of the ``LE`` class.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T145457Z" creationid="eldesh" creationdate="20200102T145457Z">
        <seg>言い換えれば、|Coq| は ``LEQ`` クラスのオブジェクトが ``LE`` クラスのオブジェクトでもあるということが分かりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In our example:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194409Z" creationid="eldesh" creationdate="20191221T194349Z">
        <seg>我々の扱っている例では:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular it contains the requirement that the two relations we are combining are compatible.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T141939Z" creationid="eldesh" creationdate="20200102T141925Z">
        <seg>特にそれは組み合わせた両立できる二つの要求を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, it uses the implicit arguments mechanism if available, as shown in the example.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T180054Z" creationid="eldesh" creationdate="20200103T180054Z">
        <seg>特に、例で示したように、それは可能であれば暗黙引数の機構を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, to be able to specify sharing of structures, one may want to give explicitly the superclasses.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T174607Z" creationid="eldesh" creationdate="20200103T174607Z">
        <seg>場合によっては、構造の共有を指定できるようにするため、スーパークラスを明示的に与えたいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, the context will probably contain some unexpected generalized variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T143308Z" creationid="eldesh" creationdate="20191226T143308Z">
        <seg>そのような場合、恐らく文脈にいくつかの意図しない一般化された変数が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, ``A`` and ``eqa`` should be set maximally implicit.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T151242Z" creationid="eldesh" creationdate="20200103T151242Z">
        <seg>上の例では、``A`` と ``eqa`` が最大限暗黙に設定されるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, a constraint ``EqDec A`` is generated and satisfied by ``eqa : EqDec A``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T144431Z" creationid="eldesh" creationdate="20200103T144431Z">
        <seg>上の例では、制約 ``EqDec A`` が生成され ``eqa : EqDec A`` によって充足されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the expression:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T171148Z" creationid="eldesh" creationdate="20191221T171148Z">
        <seg>この式では:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following proofs are omitted for brevity.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T160257Z" creationid="eldesh" creationdate="20200102T160250Z">
        <seg>以下の証明は簡潔さのため省略されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following statement for example, the variables n and m are automatically generalized and become explicit arguments of the lemma as we are using \`( ):</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T140824Z" creationid="eldesh" creationdate="20191226T140818Z">
        <seg>例えば以下の文では、\`( ) を使うことで変数 n と m は自動的に一般化され、そしてその補題の明示的引数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following subsection we show how to make them more compact.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T161346Z" creationid="eldesh" creationdate="20200102T161346Z">
        <seg>続く項ではそれらをどのようによりコンパクトにするかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the fourth part more practical tools are documented.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145717Z" creationid="yamarten" creationdate="20181104T145650Z">
        <seg>第4部はより実用的なツールについて文書化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the same way, we give the superclasses as a binding context:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T171948Z" creationid="eldesh" creationdate="20200103T171904Z">
        <seg>同様に、束縛コンテキストとしてスーパークラスを与えます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these binders, the binding name for the bound object is optional, whereas the type is mandatory, dually to regular binders.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T162836Z" creationid="eldesh" creationdate="20191226T150243Z">
        <seg>これらの束縛子の中では、束縛されたオブジェクトの束縛名はオプショナルですが、一方でその型は強制であり、通常の束縛子と双対的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case the types can be recursive and eta-conversion is disallowed.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T154757Z" creationid="eldesh" creationdate="20191225T154757Z">
        <seg>この場合は型は再帰でき、eta 変換は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case we associate to nat only one canonical value (since its class, ``nat_EQcl`` has just one member).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T115614Z" creationid="eldesh" creationdate="20191227T115614Z">
        <seg>この場合は nat に高々一つの正準値を関連付けました (そのクラスについても、``nat_EQcl`` はただ一つのメンバを持っています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this sense, the :cmd:`Record` construction allows defining “signatures”.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T165956Z" creationid="eldesh" creationdate="20191221T165956Z">
        <seg>この場合、:cmd:`Record` は ”シグネチャ” の定義をすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexes</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150216Z" creationid="yamarten" creationdate="20181104T150216Z">
        <seg>索引</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Induction schemes are automatically generated for inductive records.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201102Z" creationid="eldesh" creationdate="20191221T201102Z">
        <seg>帰納スキームは帰納的レコードについて自動的に生成される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside implicit generalization delimiters, free variables in the current context are automatically quantified using a product or a lambda abstraction to generate a closed term.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T161700Z" creationid="eldesh" creationdate="20191226T140503Z">
        <seg>暗黙の一般化デリミタの中では、現在のコンテキスト中の自由変数は、閉じた項を生成するために積またはラムダ抽象を使うことで自動的に量化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Installation</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150013Z" creationid="yamarten" creationdate="20181104T150013Z">
        <seg>インストール方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T034937Z" creationid="yamarten" creationdate="20181007T033312Z">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also tests that they work as expected.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T160634Z" creationid="eldesh" creationdate="20200102T160634Z">
        <seg>それらが期待通りに動作することをテストもします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It analyses the dependencies between subgoals to avoid backtracking on subgoals that are entirely independent.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T204237Z" creationid="eldesh" creationdate="20200103T204237Z">
        <seg>それは完全に独立したサブゴール上でのバックトラッキングを避けるため、サブゴール間の依存を解析します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be activated for printing with</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194813Z" creationid="eldesh" creationdate="20191221T194813Z">
        <seg>それは以下によって表示を有効にすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be used for redeclaring instances at the end of sections, or declaring structure projections as instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T184402Z" creationid="eldesh" creationdate="20200103T202931Z">
        <seg>それはセクションの終わりでインスタンスを再宣言したり、または構造の射影をインスタンスとして宣言するのに使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can happen that the definition of a projection is impossible.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201457Z" creationid="eldesh" creationdate="20191221T201457Z">
        <seg>射影の定義が不可能なことが起こり得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does so by allowing hints that conclude in a product to apply to a goal with a matching product directly, avoiding an introduction.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T200934Z" creationid="eldesh" creationdate="20200106T200934Z">
        <seg>それはある積の中で直接マッチする積を伴うゴールにイントロダクションを避けて適用すると結論を出すヒントを認めることで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It infers all the other pieces of the class ``LEQ`` and declares them as canonical values associated to the ``T`` key.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T213510Z" creationid="eldesh" creationdate="20200102T213510Z">
        <seg>それは ``LEQ`` クラスの他の全ての部分を推論し、キーとなる ``T`` に関連付けられた正準値としてそれらを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is actually a wrapper for several ways of defining a function *and other useful related objects*, namely: an induction principle that reflects the recursive structure of the function (see :tacn:`function induction`) and its fixpoint equality.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T142420Z" creationid="eldesh" creationdate="20191221T212941Z">
        <seg>それは実際には関数 *と他の便利な関連オブジェクト* を定義するいくつかの方法のラッパーであり、具体的には: その関数の再帰構造を反映する帰納法の原理 (:tacn:`function induction` 参照) とその不動点等式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also useful to declare constants which should never be unfolded during proof-search, like fixpoints or anything which does not look like an abbreviation.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T184909Z" creationid="eldesh" creationdate="20200106T184603Z">
        <seg>それは不動点や省略形のように見えない何かのような証明探索中にけっして展開されるべきではない定数を宣言するのにも便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is always used when calling the unifier.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T211615Z" creationid="eldesh" creationdate="20200103T211615Z">
        <seg>それは単一化器を呼ぶときに常に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is divided in six chapters.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145403Z" creationid="yamarten" creationdate="20181104T145403Z">
        <seg>ここは6つの章に分かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is is possible to do it directly in regular binders, and using the ``!`` modifier in class binders.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T230512Z" creationid="eldesh" creationdate="20200103T175645Z">
        <seg>それは通常の束縛子の中で直接行う、そしてクラス束縛子の中では ``!`` 修飾子を使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible to bind variable names to a given type (e.g. in a development using arithmetic, it may be convenient to bind the names `n` or `m` to the type ``nat`` of natural numbers).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T131945Z" creationid="eldesh" creationdate="20191226T131935Z">
        <seg>変数名を与えられた型に束縛することが可能です (例: 算術を使う開発の中で、名前 `n` や `m` を自然数である ``nat`` 型に束縛すると便利かもしれません)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is useful when some constants prevent some unifications and make resolution fail.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T184416Z" creationid="eldesh" creationdate="20200106T184416Z">
        <seg>いくつかの定数がいくらかの単一化を防ぎ、(訳注: 型クラス)解決を失敗させるのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It might move to ``all:typeclasses eauto`` in future versions when the refinement engine will be able to backtrack.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T190821Z" creationid="eldesh" creationdate="20200103T211039Z">
        <seg>精細化エンジンがバックトラック出来るようになったとき未来のバージョンではそれは ``all:typeclasses eauto`` に移動するかもしれない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a specification language named |Gallina|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T080633Z" creationid="yamarten" creationdate="20181007T080342Z">
        <seg>Coqは、 |Gallina| と呼ばれる仕様記述言語を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should be read as: “find a class e such that its objects have type T or fail with message "T is not an EQ.type"”.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T205824Z" creationid="eldesh" creationdate="20200102T204825Z">
        <seg>これは以下のように読めます: “あるクラス e を見つける。そのオブジェクトは型 T を持ち、そうでない場合は "T is not an EQ.type" というメッセージとともに失敗する”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It treats typeclass subgoals the same as other subgoals (no shelving of non-typeclass goals in particular).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T212906Z" creationid="eldesh" creationdate="20200103T212725Z">
        <seg>それは型クラスサブゴールを他のサブゴールと同じに扱います (特に非型クラスゴールに先送りがないときは)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will be type checked when it is used, an in that case ``T`` is going to be a concrete type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T214235Z" creationid="eldesh" creationdate="20200102T214235Z">
        <seg>それが使われ、``T`` が具体型になるときに型検査されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It will use local hypotheses as well as declared lemmas in the ``typeclass_instances`` database.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T223337Z" creationid="eldesh" creationdate="20200103T145400Z">
        <seg>それは ``typeclass_instances`` データベース内に定義された補題だけでなくローカルな仮定も使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its syntax is described in the grammar below.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T165519Z" creationid="eldesh" creationdate="20191221T165438Z">
        <seg>構文は以下で説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let us define the rational :math:`1/2`:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191921Z" creationid="eldesh" creationdate="20191221T191921Z">
        <seg>有理数 :math:`1/2` を定義してみましょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let us now see the work done by the ``Record`` macro.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191542Z" creationid="eldesh" creationdate="20191221T190420Z">
        <seg>``Record`` マクロによって行われる動作を見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>License</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150242Z" creationid="yamarten" creationdate="20181104T150242Z">
        <seg>ライセンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like in ``Fixpoint``, the decreasing argument must be given (unless the function is not recursive), but it might not necessarily be *structurally* decreasing.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T213200Z" creationid="eldesh" creationdate="20191221T213200Z">
        <seg>``Fixpoint`` のように、(関数が再帰していないときでさえ) 減少する引数を与えなければいけません、しかしそれが *構造的に* 減少している必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Links to several tutorials can be found at https://coq.inria.fr/documentation and https://github.com/coq/coq/wiki#coq-tutorials</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T035722Z" creationid="yamarten" creationdate="20181007T035722Z">
        <seg>https://coq.inria.fr/documentation や https://github.com/coq/coq/wiki#coq-tutorials には、幾つかのチュートリアルへのリンクがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List of additional documentation</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145841Z" creationid="yamarten" creationdate="20181104T145841Z">
        <seg>その他の文書一覧</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make the identifiers opaque for typeclass search.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T123228Z" creationid="eldesh" creationdate="20200106T123228Z">
        <seg>型クラス検索のために識別子を不透明にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Missing fields must be filled in interactive proof mode.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T194335Z" creationid="eldesh" creationdate="20200103T194335Z">
        <seg>足りないフィールドは対話証明モードで埋められなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More details and examples, and a description of the commands related to coercions are provided in :ref:`implicitcoercions`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T185249Z" creationid="eldesh" creationdate="20191226T185249Z">
        <seg>より詳細と例、それにコアーションに関連するコマンドの説明は :ref:`implicitcoercions` で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More generally, a record may have explicitly defined (a.k.a.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T190931Z" creationid="eldesh" creationdate="20191221T185102Z">
        <seg>より一般的には、レコードは明示的に定義されたフィールド (別名 マニフェスト) を持ち得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover the following are defined:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T131318Z" creationid="eldesh" creationdate="20191221T221053Z">
        <seg>さらに以下のものが定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, |Coq|’s compiler provides an output file containing a compact representation of its input.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144902Z" creationid="yamarten" creationdate="20181104T144902Z">
        <seg>さらに、 |Coq| コンパイラは、入力のコンパクトな表現を持つ出力ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No methods or instances are defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T193536Z" creationid="eldesh" creationdate="20200103T193536Z">
        <seg>メソッドやインスタンスは定義されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, the manual has some structure that is explained below.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145002Z" creationid="yamarten" creationdate="20181104T145002Z">
        <seg>とはいえ、このマニュアルも以下のような構造を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notation overloading</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T105726Z" creationid="eldesh" creationdate="20191227T105726Z">
        <seg>表記法オーバーローディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in practice the user may want to declare ``EQ.obj`` as a coercion, but we will not do that here.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T112524Z" creationid="eldesh" creationdate="20191227T112524Z">
        <seg>留意すべきは、実際にはユーザは ``EQ.obj`` をコアーションとして定義したいかもしれませんが、ここではそれは行いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that no direct proof of ``n &lt;= m -&gt; m &lt;= n -&gt; n == m`` is provided by the user for ``n`` and m of type ``nat * nat``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T162151Z" creationid="eldesh" creationdate="20200102T162049Z">
        <seg>注目すべきは ``nat * nat`` 型の ``n`` と m についての ``n &lt;= m -&gt; m &lt;= n -&gt; n == m`` の直接の証明はユーザから提供されていないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <note>instate は instance の typo ？</note>
      <tuv lang="EN-US">
        <seg>Of course one would like to apply results proved in the algebraic setting to any concrete instate of the algebraic structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T155649Z" creationid="eldesh" creationdate="20200102T152811Z">
        <seg>もちろん代数的構造のどんな具体例についても代数的な背景の中で証明された結果を適用したい人もいるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the user level, primitive projections can be used as a replacement for the usual defined ones, although there are a few notable differences.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T133701Z" creationid="eldesh" creationdate="20191225T133701Z">
        <seg>ユーザレベルでは、いくらか注目すべき違いはありますが、プリミティブ射影は普通に定義されたそれを置き換えるのに使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a typeclass is declared, one can use it in class binders:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T222627Z" creationid="eldesh" creationdate="20200103T144158Z">
        <seg>一度型クラスが宣言されると、それをクラス束縛子の中で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once proof obligations are discharged, the following objects are defined:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145855Z" creationid="eldesh" creationdate="20191222T135441Z">
        <seg>証明課題が解決されると、以下のオブジェクトが定義されます:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can also declare existing objects or structure projections using the Existing Instance command to achieve the same effect.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T112456Z" creationid="eldesh" creationdate="20200103T191112Z">
        <seg>同じ効果を達成するために Existing Instance コマンドを使うことで既存のオブジェクトや構造の射影を宣言することも出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can also parameterize classes by other classes, generating a hierarchy of classes and superclasses.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T224755Z" creationid="eldesh" creationdate="20200103T171837Z">
        <seg>他のクラスによってクラスをパラメタライズし、クラスとスーパークラスの階層を生成することも出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can also use implicit generalization for binders, in which case the generalized variables are added as binders and set maximally implicit.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T162313Z" creationid="eldesh" creationdate="20191226T144335Z">
        <seg>束縛子にも暗黙の一般化を使うことができ、その場合は一般化された変数が束縛子として追加され最大限暗黙に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can control the set of generalizable identifiers with the ``Generalizable`` vernacular command to avoid unexpected generalizations when mistyping identifiers.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T141453Z" creationid="eldesh" creationdate="20191226T141056Z">
        <seg>ヴァーナキュラーコマンド ``Generalizable`` によって一般化できる識別子の集合をコントロールし、識別子を打ち間違えた時に望まない一般化を避けることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can declare parameterized instances as in Haskell simply by giving the constraints as a binding context before the instance, e.g.:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T224018Z" creationid="eldesh" creationdate="20200103T153613Z">
        <seg>インスタンスの前に束縛コンテキストとして制約を与えることで Haskell のようにパラメータ化されたインスタンスを簡潔に宣言することが出来ます。例えば:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can distinguish them from applications of the primitive projection if the :flag`Printing Primitive Projection Parameters` option is off: For a primitive projection application, parameters are printed as underscores while for the compatibility projections they are printed as usual.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T164349Z" creationid="eldesh" creationdate="20191225T164222Z">
        <seg>:flag`Printing Primitive Projection Parameters` オプションがオフになっているとそれらとプリミティブ射影の適用と区別することが出来ます。プリミティブ射影適用のときは、パラメータはアンダースコアとして表示される一方、互換性射影は普通に表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can use alternatively the :cmd:`Program Instance` variant which has richer facilities for dealing with obligations.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T222526Z" creationid="eldesh" creationdate="20200103T144048Z">
        <seg>替わりに :cmd:`Program Instance` という類型を使うことが出来、これは課題の扱いについてよりリッチな機能を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can use the ``Global`` modifier on instances declared in a section so that their generalization is automatically redeclared after the section is closed.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T182428Z" creationid="eldesh" creationdate="20200103T201049Z">
        <seg>``Global`` 修飾子はあるセクション中で宣言されたインスタンス上で、それらの一般化されたものがそのセクションが閉じられた後に自動的に再宣言されるように使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One has to take care that the transparency of every field is determined by the transparency of the :cmd:`Instance` proof.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T222206Z" creationid="eldesh" creationdate="20200103T143448Z">
        <seg>:cmd:`Instance` の証明の透過性よって決まる全てのフィールドの透過性に注意するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One need not even mention the unique field name for singleton classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T200547Z" creationid="eldesh" creationdate="20200103T200547Z">
        <seg>シングルトンクラスについては一意なフィールド名に言及する必要すらありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One should take care not to make opaque any constant that is used to abbreviate a type, like:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T190744Z" creationid="eldesh" creationdate="20200106T190744Z">
        <seg>以下のような、型を省略するために使われる定数を不透明にしないように注意するべきです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only `ident` is defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144444Z" creationid="eldesh" creationdate="20191221T220441Z">
        <seg>`ident` だけが定義されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only `ident` is defined; the induction scheme will not be generated.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144255Z" creationid="eldesh" creationdate="20191221T215758Z">
        <seg>`ident` のみが定義され、帰納スキームは生成されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionally, you can enhance it with the minor mode Company-Coq :cite:`Pit16` (see https://github.com/cpitclaudel/company-coq).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150319Z" creationid="yamarten" creationdate="20181104T150319Z">
        <seg>また、マイナーモード Company-Coq :cite:`Pit16` (https://github.com/cpitclaudel/company-coq) で拡張することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options A and B are not elected.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150310Z" creationid="yamarten" creationdate="20181104T150310Z">
        <seg>オプションAおよびBは選択しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise said, :flag:`Printing All` includes the effects of the options :flag:`Printing Implicit`, :flag:`Printing Coercions`, :flag:`Printing Synth`, :flag:`Printing Projections`, and :flag:`Printing Notations`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T192713Z" creationid="eldesh" creationdate="20191226T192509Z">
        <seg>他の言い方をすると :flag:`Printing All` はオプション :flag:`Printing Implicit`、:flag:`Printing Coercions`、:flag:`Printing Synth`、:flag:`Printing Projections`、:flag:`Printing Notations` の効果を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise said, :token:`qualid` is canonically used to extend the field |c_i| into a complete structure built on |c_i|.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T184130Z" creationid="eldesh" creationdate="20191225T184130Z">
        <seg>別の言い方をすると、:token:`qualid` はフィールド |c_i| を |c_i| 上に構築した完全な構造に拡張するために規範的に使われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameterized Instances</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T153358Z" creationid="eldesh" creationdate="20200103T153358Z">
        <seg>パラメータ化されたインスタンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters of the function are bound in `term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134806Z" creationid="eldesh" creationdate="20191222T134806Z">
        <seg>その関数のパラメータは `term` 中で抑えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters of the function are bound in `term`\ ;</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134430Z" creationid="eldesh" creationdate="20191222T134430Z">
        <seg>関数のパラメータは `term`\ 中で抑えられます;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please report.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T220449Z" creationid="eldesh" creationdate="20191221T220449Z">
        <seg>報告してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practical tools</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150232Z" creationid="yamarten" creationdate="20181104T150232Z">
        <seg>実用ツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preamble</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150219Z" creationid="yamarten" creationdate="20181104T150219Z">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primitive Projections</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T131511Z" creationid="eldesh" creationdate="20191225T131511Z">
        <seg>プリミティブ射影</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primitive Record Types</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134212Z" creationid="eldesh" creationdate="20191225T134212Z">
        <seg>プリミティブレコード型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primitive projections extended the Calculus of Inductive Constructions with a new binary term constructor `r.(p)` representing a primitive projection `p` applied to a record object `r` (i.e., primitive projections are always applied).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T133504Z" creationid="eldesh" creationdate="20191225T133134Z">
        <seg>プリミティブ射影は Calculus of Inductive Constructions を新たな二項構築子 `r.(p)` で拡張し、これはあるレコードオブジェクト `r` に適用されるプリミティブ射影 `p` です (つまり、プリミティブ射影は常に適用されます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printing constructions in full</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T190454Z" creationid="eldesh" creationdate="20191226T190454Z">
        <seg>全ての構成を表示する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printing universes</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T193051Z" creationid="eldesh" creationdate="20191226T193051Z">
        <seg>ユニバースを表示する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To:
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T035013Z" creationid="yamarten" creationdate="20181007T035013Z">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To:
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To: 
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T035446Z" creationid="yamarten" creationdate="20181007T035446Z">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To: 
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Projections obey the usual ``simpl`` flags of the ``Arguments`` command in particular.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T161032Z" creationid="eldesh" creationdate="20191225T161032Z">
        <seg>特に射影は、``Arguments`` コマンドの通常の ``simpl`` フラグに従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proof-General is available at https://proofgeneral.github.io/.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150315Z" creationid="yamarten" creationdate="20181104T150315Z">
        <seg>Proof-General は https://proofgeneral.github.io/から入手可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Record types</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T164758Z" creationid="eldesh" creationdate="20191221T164758Z">
        <seg>レコード型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records  cannot  be  defined  as  part  of  mutually  inductive  (or co-inductive) definitions,  whether with records only  or mixed with standard definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T203221Z" creationid="eldesh" creationdate="20191221T203221Z">
        <seg>レコードは、レコードのみであっても標準定義との混合であっても、相互帰納的 (または余帰納的) 定義の一部として定義することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Records defined with the ``Record`` keyword are not allowed to be recursive (references to the record's name in the type of its field raises an  error).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200639Z" creationid="eldesh" creationdate="20191221T195837Z">
        <seg>``Record`` キーワードで定義されたレコードは再帰することは許されません (レコード名への参照がそのフィールドの型の中にあるとエラーが起きる)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reduction</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160237Z" creationid="eldesh" creationdate="20191225T160237Z">
        <seg>簡約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark here that the fields ``Rat_bottom_cond`` depends on the field ``bottom`` and ``Rat_irred_cond`` depends on both ``top`` and ``bottom``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191027Z" creationid="eldesh" creationdate="20191221T190253Z">
        <seg>ここで注意すべきはフィールド ``Rat_bottom_cond`` がフィールド ``bottom`` に依存し、 ``Rat_irred_cond`` が ``top`` と ``bottom`` の両方に依存していることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark that the type of a particular identifier may depend on a previously-given identifier.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183949Z" creationid="eldesh" creationdate="20191221T183949Z">
        <seg>注目すべきは、特定の識別子の型は前に与えられた識別子に依存し得ることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark: Proof obligations are presented as several subgoals belonging to a Lemma `ident`\ :math:`_{\sf tcc}`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T150212Z" creationid="eldesh" creationdate="20191222T141818Z">
        <seg>注意: 証明課題は補題 `ident`\ :math:`_{\sf tcc}` に付随するいくつかのサブゴールとして提示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remark: To obtain the right principle, it is better to put rigid parameters of the function as first arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T214637Z" creationid="eldesh" creationdate="20191221T214118Z">
        <seg>注意: 正しい原理を得るには、第一引数として関数の固定されたパラメータを与えるのがより良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <note>型クラスに於いてはコンテキストという単語で定着している気がする</note>
      <tuv lang="EN-US">
        <seg>Sections and contexts</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T160326Z" creationid="eldesh" creationdate="20200103T160326Z">
        <seg>セクションとコンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See :ref:`Sorts` for details.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T193850Z" creationid="eldesh" creationdate="20191226T193837Z">
        <seg>詳細については :ref:`Sorts` を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the documentation of functional induction (:tacn:`function induction`) and ``Functional Scheme`` (:ref:`functional-scheme`) for how to use the induction principle to easily reason about the function.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T214113Z" creationid="eldesh" creationdate="20191221T214113Z">
        <seg>どのように帰納法の原理を使って簡単にその関数について論じるかについては関数的帰納法 (:tacn:`function induction`) と ``Functional Scheme`` (:ref:`functional-scheme`) のドキュメントを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the table of contents for a complete list.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145836Z" creationid="yamarten" creationdate="20181104T145836Z">
        <seg>全ての項目を知りたい場合は、目次を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting this flag also sets :opt:`Typeclasses Debug Verbosity` to 1.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T205128Z" creationid="eldesh" creationdate="20200106T205128Z">
        <seg>またこのフラグは :opt:`Typeclasses Debug Verbosity` を 1 に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting this option also sets :flag:`Typeclasses Debug`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T205509Z" creationid="eldesh" creationdate="20200106T205509Z">
        <seg>このオプションを設定すると :flag:`Typeclasses Debug` も設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, we could equip any other type with a comparison relation, and use the ``==`` notation on terms of this type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T121502Z" creationid="eldesh" creationdate="20191227T121456Z">
        <seg>同様に、他のどんな型でも比較関係を整えて、そしてこの型の項の上で ``==`` 記法を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So each time a reflexive relation is needed, a preorder can be used instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T112444Z" creationid="eldesh" creationdate="20200103T185747Z">
        <seg>従って反射的関係が必要になるたび、代わりに前順序を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies a set of qualids which are displayed as constructors.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193816Z" creationid="eldesh" creationdate="20191221T193816Z">
        <seg>コンストラクタとして表示される qualid の集合を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>qualids って何？</note>
      <tuv lang="EN-US">
        <seg>Specifies a set of qualids which are displayed as records.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193637Z" creationid="eldesh" creationdate="20191221T193600Z">
        <seg>レコードとして表示される qualid の集合を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Still, no concrete type is in the ``EQ`` class.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T113031Z" creationid="eldesh" creationdate="20191227T113031Z">
        <seg>まだ ``EQ`` クラスの中には具体的な型はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Substructures</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T180707Z" creationid="eldesh" creationdate="20200103T180707Z">
        <seg>部分構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Substructures are components of a class which are instances of a class themselves.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T112427Z" creationid="eldesh" creationdate="20200103T180801Z">
        <seg>部分構造はクラスのインスタンス自身であるようなクラスの構成要素です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such notation will be overloaded, and its meaning will depend on the types of the terms that are compared.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T105847Z" creationid="eldesh" creationdate="20191227T105847Z">
        <seg>そのような記法はオーバーロードされ、その意味は比較される項の型に依存することになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary of the commands</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T191128Z" creationid="eldesh" creationdate="20200103T191128Z">
        <seg>コマンドの概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Superclasses</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T171325Z" creationid="eldesh" creationdate="20200103T171325Z">
        <seg>スーパークラス</seg>
      </tuv>
    </tu>
    <tu>
      <note>obligation mechanism</note>
      <tuv lang="EN-US">
        <seg>Switches the type checking to Program (chapter :ref:`programs`) and uses the obligation mechanism to manage missing fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T182647Z" creationid="eldesh" creationdate="20200103T201231Z">
        <seg>型検査を Program (章 :ref:`programs`) に切り替え、足りないフィールドを管理する(訳注: 証明)課題機構を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax of Record projections</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194831Z" creationid="eldesh" creationdate="20191221T194831Z">
        <seg>レコード射影構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table of contents</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150213Z" creationid="yamarten" creationdate="20181104T150213Z">
        <seg>目次</seg>
      </tuv>
    </tu>
    <tu>
      <note>as well asのニュアンスを落としてるので、「仕様記述言語のはずでは？」となりそうな気もする</note>
      <tuv lang="EN-US">
        <seg>Terms of |Gallina| can represent programs as well as properties of these programs and proofs of these properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T081041Z" creationid="yamarten" creationdate="20181007T081041Z">
        <seg>|Gallina| の項はプログラム・プログラムの性質・性質の証明を表現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to :g:`nat_setoid` declared as canonical, the implicit arguments :g:`A` and :g:`B` can be synthesized in the next statement.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185303Z" creationid="eldesh" creationdate="20191225T184648Z">
        <seg>:g:`nat_setoid` が正準として定義されているおかげで、次のステートメント内で暗黙引数 :g:`A` と :g:`B` が合成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to the ``pair_EQty`` declaration, |Coq| is able to build a comparison relation for pairs whenever it is able to build a comparison relation for each component of the pair.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T123746Z" creationid="eldesh" creationdate="20191227T123746Z">
        <seg>``pair_EQty`` 定義のおかげで、|Coq| はそのペアの各コンポーネントの比較関数を構築することが出来るときは、いつでもペアのための比較関係を構築することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The :cmd:`Class` command is used to declare a typeclass with parameters ``binders`` and fields the declared record fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T154755Z" creationid="eldesh" creationdate="20200103T192055Z">
        <seg>:cmd:`Class` コマンドはパラメータ ``binders`` とレコードフィールドを宣言するフィールドを伴う型クラスの宣言に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The :cmd:`Instance` command is used to declare a typeclass instance named ``ident`` of the class :cmd:`Class` with parameters ``t1`` to ``tn`` and fields ``b1`` to ``bi``, where each field must be a declared field of the class.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T181853Z" creationid="eldesh" creationdate="20200103T194232Z">
        <seg>:cmd:`Instance` コマンドは ``ident`` という名前の型クラスインスタンスを宣言するのに使われます。クラス :cmd:`Class` はパラメータ ``t1`` から ``tn`` とフィールド ``b1`` から ``bi`` を伴い、各フィールドはそのクラスの宣言されたフィールドでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The :cmd:`Record` construction is a macro allowing the definition of records as is done in many programming languages.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184600Z" creationid="eldesh" creationdate="20191221T165051Z">
        <seg>:cmd:`Record` は多くのプログラミング言語で行われるようにレコードを定義できるようにするマクロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Gallina specification language</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181110T115315Z" creationid="yamarten" creationdate="20181110T115315Z">
        <seg>仕様記述言語 Gallina</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ``!`` modifier switches the way a binder is parsed back to the regular interpretation of Coq.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T230725Z" creationid="eldesh" creationdate="20200103T175825Z">
        <seg>この ``!`` 修飾子は束縛子が解析されCoqの通常の解釈に解析される方法を切り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ``Function`` construction also enjoys the ``with`` extension to define mutually recursive definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T142946Z" creationid="eldesh" creationdate="20191221T213800Z">
        <seg>``Function`` による構成はさらに ``with`` 拡張により相互再帰定義を定義することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ``{}`` annotation is mandatory and must be one of the following:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134030Z" creationid="eldesh" creationdate="20191222T134030Z">
        <seg>``{}`` の注釈は強制であり、以下のうちの一つでないといけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `coqtop` read-eval-print-loop can also be used directly, for debugging purposes.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144829Z" creationid="yamarten" creationdate="20181104T111736Z">
        <seg>デバッグのために、 read-eval-print-loop である `coqtop` を直接用いることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>variant をどう訳すか？</note>
      <tuv lang="EN-US">
        <seg>The algorithm used to solve constraints is a variant of the :tacn:`eauto` tactic that does proof search with a set of lemmas (the instances).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T144837Z" creationid="eldesh" creationdate="20200103T144736Z">
        <seg>制約を解消するために使われるアルゴリズムは :tacn:`eauto` タクティックの類型で、それは補題 (インスタンス) の集合をもって証明探索を行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base namespace contains the definitions of the algebraic structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T130549Z" creationid="eldesh" creationdate="20191227T110907Z">
        <seg>この基本名前空間は代数構造の定義を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic reduction rule of a primitive projection is |p_i| ``(Build_``\ `R` |t_1| … |t_n|\ ``)`` :math:`{\rightarrow_{\iota}}` |t_i|.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160326Z" creationid="eldesh" creationdate="20191225T160326Z">
        <seg>プリミティブ射影の基本的な簡約規則は |p_i| ``(Build_``\ `R` |t_1| … |t_n|\ ``)`` :math:`{\rightarrow_{\iota}}` |t_i| です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of `ident` uses an incorrect elimination for `ident` (see :cmd:`Fixpoint` and :ref:`Destructors`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202633Z" creationid="eldesh" creationdate="20191221T202037Z">
        <seg>`ident` のボディーは `ident` に不正な除去を使っている (:cmd:`Fixpoint` と :ref:`Destructors` 参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <note>定数を使っても具体化されずにちゃんと型クラスを使ったシグネチャになるってことかな</note>
      <tuv lang="EN-US">
        <seg>The class constant itself is declared rigid during resolution so that the class abstraction is maintained.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T175223Z" creationid="eldesh" creationdate="20200103T193251Z">
        <seg>そのクラス定数自身は(訳注: 制約を)解消する間は厳格に決定され、そのためそのクラスの抽象は維持されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The combination of these two facts is a simple form of proof search that |Coq| performs automatically while inferring canonical structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T163207Z" creationid="eldesh" creationdate="20200102T163152Z">
        <seg>これら二つの事実の組み合わせは正準構造を推論している間、|Coq| が自動的に行う証明探索の単純な形です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The command for that is</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T132008Z" creationid="eldesh" creationdate="20191226T132008Z">
        <seg>そのためのコマンドは</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiled mode acts as a proof checker taking a file containing a whole development in order to ensure its correctness.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144849Z" creationid="yamarten" creationdate="20181104T144849Z">
        <seg>コンパイルモードは、開発したもの全てを受け取り、その正当性を保証する証明チェッカとして機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiled mode is run with the `coqc` command.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144910Z" creationid="yamarten" creationdate="20181104T144910Z">
        <seg>コンパイルモードは `coqc` コマンドで実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The complete documentation of canonical structures can be found in :ref:`canonicalstructures`; here only a simple example is given.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T182728Z" creationid="eldesh" creationdate="20191225T182728Z">
        <seg>正準構造の完全なドキュメントは :ref:`canonicalstructures` で見つけられます; ここでは単純な例のみを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constraints on the internal level of the occurrences of Type (see :ref:`Sorts`) can be printed using the command</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T101956Z" creationid="eldesh" creationdate="20191226T195254Z">
        <seg>Type の出現の内部的なレベルについての制約 (:ref:`Sorts` 参照) はこのコマンドを使うことで表示できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding grammar rules are given in the preceding grammar.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200603Z" creationid="eldesh" creationdate="20191221T195009Z">
        <seg>対応する文法規則は前述の文法の中で与えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration associates to the key ``*`` (the type constructor of pairs) the canonical comparison relation ``pair_eq`` whenever the type constructor ``*`` is applied to two types being themselves in the ``EQ`` class.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T134111Z" creationid="eldesh" creationdate="20191227T124242Z">
        <seg>その定義は型コンストラクタ ``*`` がそれら自身が ``EQ`` クラスの中にある二つの型に適用されるときは、キーである ``*`` (ペアの型コンストラクタ) に正準比較関係 ``pair_eq`` を関連付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration of canonical instances can now be way more compact:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T220417Z" creationid="eldesh" creationdate="20200102T220417Z">
        <seg>正準インスタンスの定義は今やよりコンパクトになりえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The defined type enjoys eta-conversion definitionally, that is the generalized form of surjective pairing for records: `r` ``= Build_``\ `R` ``(``\ `r`\ ``.(``\ |p_1|\ ``) …`` `r`\ ``.(``\ |p_n|\ ``))``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T154211Z" creationid="eldesh" creationdate="20191225T154211Z">
        <seg>定義された型は定義的に eta 変換を使うことが出来、それは `r` ``= Build_``\ `R` ``(``\ `r`\ ``.(``\ |p_1|\ ``) …`` `r`\ ``.(``\ |p_n|\ ``))`` というレコードの全射ペアリングの一般的な形です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effect of the command is to automatically set the type of bound variables starting with `ident` (either `ident` itself or `ident` followed by one or more single quotes, underscore or digits) to be `type` (unless the bound variable is already declared with an explicit type in which case, this latter type is considered).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T151338Z" creationid="eldesh" creationdate="20191226T132204Z">
        <seg>このコマンドの効果は `ident` で始まる (`ident` 自身または `ident` に一つ以上のシングルクォート、アンダースコア、数字が続く) 束縛変数の型を自動的に `type` (その束縛変数が明示的な型とともに既に定義されている場合でない限り、後者の型と見なされる) に設定するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The error message is telling that |Coq| has no idea on how to compare pairs of objects.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T122459Z" creationid="eldesh" creationdate="20191227T122408Z">
        <seg>このエラーメッセージは |Coq| がオブジェクトのペアをどのように比較するかについて知らないと言っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples are taken from :cite:`CSwcu`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T104711Z" creationid="eldesh" creationdate="20191227T104711Z">
        <seg>例は :cite:`CSwcu` から抜粋しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fields do not have to be in any particular order, nor do they have to be all present if the missing ones can be inferred or prompted for (see :ref:`programs`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193302Z" creationid="eldesh" creationdate="20191221T192858Z">
        <seg>フィールドは特定の順序になっている必要はなく、もし足りないものが推論され得るか入力を促される (:ref:`programs` 参照) ならば、それらは全てが存在する必要もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fifth part documents a number of advanced features, including coercions, canonical structures, typeclasses, program extraction, and specialized solvers and tactics.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145822Z" creationid="yamarten" creationdate="20181104T145822Z">
        <seg>第5部では、型強制・正準構造・型クラス・プログラム抽出・特殊なソルバとタクティックといった、いくつかの高度な機能について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first part describes the specification language, |Gallina|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145011Z" creationid="yamarten" creationdate="20181104T145011Z">
        <seg>第1部では、仕様記述言語 |Gallina| について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fixpoint equation of `ident`: `ident_equation`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145055Z" creationid="eldesh" creationdate="20191222T133620Z">
        <seg>`ident`: `ident_equation` という形の不動点方程式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following construction is telling Coq exactly how to do that.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T122538Z" creationid="eldesh" creationdate="20191227T122538Z">
        <seg>以下の構成は Coq にまさにそれをどのように行うかを教えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following experimental command is available when the ``FunInd`` library has been loaded via ``Require Import FunInd``:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T212441Z" creationid="eldesh" creationdate="20191221T212441Z">
        <seg>以下の実験的なコマンドは ``FunInd`` ライブラリが ``Require Import FunInd`` によってロードされたときに有効になります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following line tests that, when we assume a type ``e`` that is in theEQ class, we can relate two of its objects with ``==``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T112940Z" creationid="eldesh" creationdate="20191227T112940Z">
        <seg>以下の行では EQ クラス内の型 ``e`` を仮定したとき、``==`` によってそのオブジェクト二つを関連付けることが出来ることをテストしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following script registers an ``LEQ`` class for ``nat`` and for the type constructor ``*``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T160609Z" creationid="eldesh" creationdate="20200102T160609Z">
        <seg>以下のスクリプトは ``LEQ`` クラスに ``nat`` と型コンストラクタ ``*`` を登録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following settings let you control the display format for types:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193010Z" creationid="eldesh" creationdate="20191221T193010Z">
        <seg>以下の設定は型の表示形式をコントロールします:</seg>
      </tuv>
    </tu>
    <tu>
      <note>文法が分からん</note>
      <tuv lang="EN-US">
        <seg>The following two constructions tell |Coq| how to canonically build the ``LE.type`` and ``EQ.type`` structure given an ``LEQ.type`` structure on the same type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T151755Z" creationid="eldesh" creationdate="20200102T150136Z">
        <seg>以下の二つの構成は |Coq| に ``LE.type`` と ``EQ.type`` 構造を同じ型上で与えられた ``LEQ.type`` 構造からどのように標準的に構築するかを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format is unspecified if `string` doesn’t end in ``.dot`` or ``.gv``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T101408Z" creationid="eldesh" creationdate="20191227T101408Z">
        <seg>`string` が ``.dot`` または ``.gv`` で終わらない場合はフォーマットは指定されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generalizing binders \`{ } and \`( ) work similarly to their explicit counterparts, only binding the generalized variables implicitly, as maximally-inserted arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T162756Z" creationid="eldesh" creationdate="20191226T144515Z">
        <seg>一般化された束縛子 \`{ } や \`( ) はそれらの明示的な場合の対応部分と同じように動作し、一般化された変数を最大限挿入された引数として暗黙に束縛するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generation of the graph relation (`R_ident`) succeeded but the induction principle could not be built.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144409Z" creationid="eldesh" creationdate="20191221T220426Z">
        <seg>グラフ関係 (`R_ident`) の生成は成功したが、その帰納法の原理は構築できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generation of the graph relation (`R_ident`) used to compute the induction scheme of ident raised a typing error.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144251Z" creationid="eldesh" creationdate="20191221T215701Z">
        <seg>ident の帰納法の原理を算出するのに使われるグラフ関係 (`R_ident`) の生成は型付けエラーを発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>クレジットへのリンクは張らないのか？</note>
      <tuv lang="EN-US">
        <seg>The history of this formalism as well as pointers to related work are provided in a separate chapter; see *Credits*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The identifiers inside the brackets are the names of fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T183245Z" creationid="eldesh" creationdate="20191221T183245Z">
        <seg>ブラケットの中の識別子はフィールド名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation simply declares each projection as an instance.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T190740Z" creationid="eldesh" creationdate="20200103T190740Z">
        <seg>その実装は単純に各射影をインスタンスとして定義するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inductive `R_ident` corresponding to the graph of `ident` (silently);</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133242Z" creationid="eldesh" creationdate="20191222T133242Z">
        <seg>帰納的 `R_ident` は (暗黙に) `ident` のグラフに対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inner theory module contains the overloaded notation ``==`` and will eventually contain lemmas holding all the instances of the algebraic structure (in this case there are no lemmas).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T130750Z" creationid="eldesh" creationdate="20191227T112354Z">
        <seg>内部のtheoryモジュールはオーバーロードされた記法 ``==`` を含み、その代数構造の全てのインスタンスを保持する補題をも含みます (この場合は補題はありません)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interactive mode is generally run with the help of an IDE, such as CoqIDE, documented in :ref:`coqintegrateddevelopmentenvironment`, Emacs with Proof-General :cite:`Asp00` [#PG]_, or jsCoq to run Coq in your browser (see https://github.com/ejgallego/jscoq).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T161431Z" creationid="yamarten" creationdate="20181104T111701Z">
        <seg>対話モードは一般的に, CoqIDE (:ref:`coqintegrateddevelopmentenvironment` にて記載)やProof-General :cite:`Asp00` [#PG]_ を入れた Emacs 、またはブラウザ上で動作する jsCoq (https://github.com/ejgallego/jscoq) のようなIDEの助けを借りて実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interested reader shall also find in :cite:`CSlessadhoc` a detailed description of another, complementary, use of canonical structures: advanced proof search.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T105452Z" creationid="eldesh" creationdate="20191227T105452Z">
        <seg>興味のある読者は :cite:`CSlessadhoc` にも別の、相補的な、正準構造の使用: 高度な証明探索 についての詳細な説明を発見するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150221Z" creationid="yamarten" creationdate="20181104T150221Z">
        <seg>言語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language to combine these tactics into complex proof strategies is given in Chapter :ref:`ltac`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145611Z" creationid="yamarten" creationdate="20181104T145611Z">
        <seg>これらのタクティックを組み合わせて複雑な証明戦略を作るための言語については :ref:`ltac` の章で述べています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lemma `ident`\ :math:`_{\sf tcc}` which collects all proof obligations in one property;</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T135650Z" creationid="eldesh" creationdate="20191222T135553Z">
        <seg>補題 `ident`\ :math:`_{\sf tcc}` これは全ての証明課題を集めて一つの性質にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lemmas `ident`\ :math:`_{\sf terminate}` and `ident`\ :math:`_{\sf F}` which is needed to be inlined during extraction of ident.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T135808Z" creationid="eldesh" creationdate="20191222T135808Z">
        <seg>補題 `ident`\ :math:`_{\sf terminate}` と `ident`\ :math:`_{\sf F}` これは indent のエクストラクションをする間にインライン化するために必要となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The macro generates also, when it is possible, the projection functions for destructuring an object of type `\ident`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194125Z" creationid="eldesh" creationdate="20191221T194125Z">
        <seg>そのマクロはさらに、それが可能な時は `\ident` 型のオブジェクトをデストラクトするための射影関数をも生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main differences are the following:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T203433Z" creationid="eldesh" creationdate="20200103T203433Z">
        <seg>主な違いは以下です:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of this declaration is to define a function ident, similarly to ``Fixpoint`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T142624Z" creationid="eldesh" creationdate="20191221T213020Z">
        <seg>この定義の意味は関数 ident を定義することで、``Fixpoint`` に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mixin component of the ``LEQ`` class contains all the extra content we are adding to ``EQ`` and ``LE``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T141519Z" creationid="eldesh" creationdate="20191229T131251Z">
        <seg>```LEQ``` クラスの構成部品 mixin は ``EQ`` と ``LE`` に追加している特別な内容を全て含んでいます.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The module ``Recdef`` of the standard library must be loaded for this feature.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133949Z" creationid="eldesh" creationdate="20191222T133949Z">
        <seg>この機能を使うには標準ライブラリの ``Recdef`` モジュールがロードされていないといけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name `ident` already exists in the environment (see :cmd:`Axiom`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202047Z" creationid="eldesh" creationdate="20191221T201857Z">
        <seg>名前 `ident` が既に環境中に存在する (:cmd:`Axiom` 参照)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new command works similarly to the :cmd:`Variables` vernacular, except it accepts any binding context as argument.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T224434Z" creationid="eldesh" creationdate="20200103T161617Z">
        <seg>その新しいコマンドはどんな束縛コンテキストでも引数として受け入れるということを除き、:cmd:`Variables` Vernacular と同じように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The object ``Pack`` takes a type ``T`` (the key) and a mixin ``m``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T213717Z" creationid="eldesh" creationdate="20200102T213314Z">
        <seg>オブジェクト ``Pack`` は型 ``T`` (キー) と mixin ``m`` を取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The odd arguments ``_`` and ``id`` we pass to the packager represent respectively the classes to be inferred (like ``e``, ``o``, etc) and a token (``id``) to force their inference.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T215840Z" creationid="eldesh" creationdate="20200102T215113Z">
        <seg>packager に渡した奇妙な引数 ``_`` と ``id`` はそれぞれ推論されるべきクラス (``e`` や ``o`` その他) とそれらの推論を強制するためのトークン (``id``) を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional identifier following ``:=`` is the name of its constructor.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T182809Z" creationid="eldesh" creationdate="20191221T182809Z">
        <seg>``:=`` に続くオプショナルな識別子はそのコンストラクタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order must be well-founded.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134747Z" creationid="eldesh" creationdate="20191222T134747Z">
        <seg>その順序は整礎でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other utilities are used to ask |Coq| to solve a specific unification problem, that will in turn require the inference of some canonical structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T210602Z" creationid="eldesh" creationdate="20200102T210556Z">
        <seg>他のユーティリティは |Coq| に正準構造の推論を必要とすることになるであろう特定的な単一化問題を解くように要求するのに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameters of the subclass contain at least all the parameters of its superclasses in their order of appearance (here A is the only one).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T172512Z" creationid="eldesh" creationdate="20200103T172512Z">
        <seg>サブクラスのパラメータは少なくともそのスーパークラスのパラメータ全てをそれらの出現順で含みます (ここでは A ただ一つです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The point of the {} annotation is to name the decreasing argument *and* to describe which kind of decreasing criteria must be used to ensure termination of recursive calls.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T142851Z" creationid="eldesh" creationdate="20191221T213320Z">
        <seg>{} 注釈のポイントは減少する引数に名前をつけること *そして* 再帰呼び出しの停止性を保証するためにどの種類の減少基準を使うべきなのかを説明することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem is that the two classes ``LE`` and ``LEQ`` are not yet related by a subclass relation.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T142617Z" creationid="eldesh" creationdate="20200102T142617Z">
        <seg>問題は ``LE`` と ``LEQ`` という二つのクラスが未だにサブクラス関係によって関連付いてないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proof engine</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150224Z" creationid="yamarten" creationdate="20181104T150224Z">
        <seg>証明エンジン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The record name `ident` appears in the type of its fields, but uses the keyword ``Record``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202802Z" creationid="eldesh" creationdate="20191221T202744Z">
        <seg>レコード名 `ident` がそのフィールドの型の中に現れているが、``Record`` キーワードを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same objects as above;</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133526Z" creationid="eldesh" creationdate="20191222T133526Z">
        <seg>上と同じオブジェクト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same objects as with the struct;</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145922Z" creationid="eldesh" creationdate="20191222T135519Z">
        <seg>struct を用いたときと同じオブジェクト;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second part describes the proof engine.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145355Z" creationid="yamarten" creationdate="20181104T145355Z">
        <seg>第2部では、証明エンジンについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics for the limit :n:`@num` is different than for auto.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T212211Z" creationid="eldesh" creationdate="20200103T212211Z">
        <seg>:n:`@num` 制限の意味は auto と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The semantics of the options are:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T210809Z" creationid="eldesh" creationdate="20200106T210809Z">
        <seg>オプションの意味は:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The set of rational numbers may be defined as:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191017Z" creationid="eldesh" creationdate="20191221T190001Z">
        <seg>有理数の集合は以下のように定義されるかもしれません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax ``:&gt;`` indicates that each ``PreOrder`` can be seen as a ``Reflexive`` relation.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T185648Z" creationid="eldesh" creationdate="20200103T185648Z">
        <seg>``:&gt;`` 構文は ``PreOrder`` それぞれが ``Reflexive`` 関係と見なせることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for class and instance declarations is the same as the record syntax of Coq:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T211540Z" creationid="eldesh" creationdate="20200103T135726Z">
        <seg>クラスとインスタンスの宣言の構文は Coq のレコード構文と同じです:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tactic ``autoapply`` applies a term using the transparency information of the hint database ident, and does *no* typeclass resolution.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T192623Z" creationid="eldesh" creationdate="20200103T213204Z">
        <seg>タクティック ``autoapply`` はヒントデータベース ident の透過性情報を使用し term を適用し、型クラス解決は *行いません*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third part describes how to extend the syntax of |Coq| in Chapter :ref:`syntaxextensionsandinterpretationscopes` and how to define new induction principles in Chapter :ref:`proofschemes`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145639Z" creationid="yamarten" creationdate="20181104T145639Z">
        <seg>第3部は、 :ref:`syntaxextensionsandinterpretationscopes` の章で|Coq| の構文の拡張方法を、 :ref:`proofschemes` の章で帰納法の原理を新たに定義する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transparency information of databases is used consistently for all hints declared in them.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T211537Z" creationid="eldesh" creationdate="20200103T211537Z">
        <seg>データベースの透過性情報はそれらの中で定義された全てのヒントと一貫して使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the projections `ident` depends on previous projections which themselves could not be defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202454Z" creationid="eldesh" creationdate="20191221T202454Z">
        <seg>`ident` の射影の型がそれ自身の以前の射影に依存していると定義できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The underlying formal language of |Coq| is a *Calculus of Inductive Constructions* (|Cic|) whose inference rules are presented in this chapter.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181110T110830Z" creationid="yamarten" creationdate="20181110T110830Z">
        <seg>|Coq| の基礎となる形式言語は *Calculus of Inductive Constructions* (|Cic|) と呼ばれる。この章では、 |Cic| の推論規則について説明する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of the projection ``op`` requires its argument to be in the class ``EQ``, and uses such a member (function) to actually compare its arguments.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T121918Z" creationid="eldesh" creationdate="20191227T121049Z">
        <seg>射影 ``op`` の使用はその引数が ``EQ`` クラスに属していることを要求し、そのようなメンバ (関数) を実際にその引数を比較するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <note>「compiles to its specification」ってなんだ。</note>
      <tuv lang="EN-US">
        <seg>The very heart of the |Coq| system is the type checking algorithm that checks the correctness of proofs, in other words that checks that a program complies to its specification.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T102409Z" creationid="yamarten" creationdate="20181007T101423Z">
        <seg>|Coq| システムの心臓部は型検査アルゴリズムで、これは証明の正しさを検査します。言い換えれば、このアルゴリズムはプログラムがその仕様に準拠するか検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The way this recursive function is defined is the subject of several papers by Yves Bertot and Antonia Balaa on the one hand, and Gilles Barthe, Julien Forest, David Pichardie, and Vlad Rusu on the other hand.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T141611Z" creationid="eldesh" creationdate="20191222T141611Z">
        <seg>この方法により再帰関数が定義される方法は、一方で Yves Bertot と Antonia Balaa による、もう一方で Gilles Barthe、Julien Forest、David Pichardie、Vlad Rusu によるいくつかの論文の主題です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The |Coq| standard library</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150201Z" creationid="yamarten" creationdate="20181104T150201Z">
        <seg>|Coq| 標準ライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The |Coq| system is designed to develop mathematical proofs, and especially to write formal specifications, programs and to verify that programs are correct with respect to their specifications.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T040420Z" creationid="yamarten" creationdate="20181007T035904Z">
        <seg>|Coq| は、数学的な証明を構築するためにデザインされました。特に、形式仕様やプログラムを記述したり、プログラムが仕様に沿っていることを検証することを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The |p_i| ``:`` |t_i| variables are called the *parameters* of the class and the |f_i| ``:`` |t_i| are called the *methods*.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T135902Z" creationid="eldesh" creationdate="20200103T135902Z">
        <seg>変数 |p_i| ``:`` |t_i| はクラスの *パラメータ* と呼ばれ、|f_i| ``:`` |t_i| は *メソッド* と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then the user is able to apply an object that is not a function, but can be coerced to a function, and more generally to consider that a term of type ``A`` is of type ``B`` provided that there is a declared coercion between ``A`` and ``B``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T185007Z" creationid="eldesh" creationdate="20191226T185007Z">
        <seg>するとユーザは関数ではないが、関数にコアーションされるオブジェクトを適用することが出来、さらに一般的にはこう考えられる。ある項の型は ``A`` であり、``A`` と ``B`` の間に定義されたコアーションがあることで提供される型 ``B`` である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, each time an equation of the form ``(``\ |x_i| ``_)`` |eq_beta_delta_iota_zeta| |c_i| has to be solved during the type checking process, :token:`qualid` is used as a solution.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T183439Z" creationid="eldesh" creationdate="20191225T183402Z">
        <seg>すると、型検査の過程でそれぞれ ``(``\ |x_i| ``_)`` |eq_beta_delta_iota_zeta| |c_i| という形の方程式を解く必要があり、:token:`qualid` が解として使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>distributionのいい感じの訳語が欲しい。</note>
      <tuv lang="EN-US">
        <seg>Then, in Chapter :ref:`utilities`, various utilities that come with the |Coq| distribution are presented.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145806Z" creationid="yamarten" creationdate="20181104T145806Z">
        <seg>次に、 :ref:`utilities` の章で、 |Coq| ディストリビューションに付属する様々なユーティリティについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are currently two ways to introduce primitive records types:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T144942Z" creationid="eldesh" creationdate="20191225T144942Z">
        <seg>今のところプリミティブレコード型を導入するには二つの方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several commands that specify which variables should be generalizable.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T141521Z" creationid="eldesh" creationdate="20191226T141521Z">
        <seg>どの変数が一般化されるべきかを指定するコマンドがいくつかあります。</seg>
      </tuv>
    </tu>
    <tu>
      <note>オプション(Setするやつ)についての索引は無視？</note>
      <tuv lang="EN-US">
        <seg>There is a global index, and a number of specific indexes for tactics, vernacular commands, and error messages and warnings.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144950Z" creationid="yamarten" creationdate="20181104T144950Z">
        <seg>総合索引に加え、タクティックやコマンド、エラーメッセージ・警告に特化した索引があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is currently no way to input unfolded primitive projections at the user-level, and one must use the :flag:`Printing Primitive Projection Compatibility` to display unfolded primitive projections as matches and distinguish them from folded ones.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T140041Z" creationid="eldesh" creationdate="20191225T161423Z">
        <seg>現在のところはユーザレベルで非畳み込みプリミティブ射影を入力する方法は無く、非畳み込みプリミティブ射影をマッチとして表示し、それらを畳み込みのそれと区別するには :flag:`Printing Primitive Projection Compatibility` を使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be three reasons:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201816Z" creationid="eldesh" creationdate="20191221T201816Z">
        <seg>3通りの可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are used when elaborating partial applications of the projection.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T163922Z" creationid="eldesh" creationdate="20191225T163922Z">
        <seg>これらの定数はその射影の部分適用の精緻化のときに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These instances are used just as well as lemmas in the instance hint database.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T160254Z" creationid="eldesh" creationdate="20200103T160124Z">
        <seg>これらのインスタンスはインスタンスヒントデータベースの中の補題だけでなく使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kind of record types differ from their traditional versions in the sense that dependent elimination is not available for them and only non-dependent case analysis can be defined.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T155555Z" creationid="eldesh" creationdate="20191225T155335Z">
        <seg>これらの種類のレコード型は、依存除去が出来ず、非依存場合分けのみが定義できるという意味での伝統的なバージョンとは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These may be used as parts of other classes:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T185502Z" creationid="eldesh" creationdate="20200103T185502Z">
        <seg>これらは他のクラスの一部として使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These projection functions are given the names of the corresponding fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T194207Z" creationid="eldesh" creationdate="20191221T194207Z">
        <seg>これらの射影関数は対応するフィールド名から与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These proofs are: proofs that each recursive call is actually decreasing with respect to the given criteria, and (if the criteria is `wf`) a proof that the ordering relation is well-founded.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145659Z" creationid="eldesh" creationdate="20191222T135258Z">
        <seg>これらの証明は: 各再帰呼び出しが実際に与えられた基準に照らして減少することの証明であり、そして (もしその基準が `wf` ならば) その順序関係は整礎である証明です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They also support implicit quantification on :ref:`superclasses`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T152232Z" creationid="eldesh" creationdate="20200103T152232Z">
        <seg>それらは :ref:`superclasses` に於ける暗黙の量化もサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are explained in more details in :cite:`CSwcu`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T210650Z" creationid="eldesh" creationdate="20200102T210650Z">
        <seg>それらは :cite:`CSwcu` の中でより詳細に説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They automatically set the maximally implicit status for typeclass arguments, making derived functions as easy to use as class methods.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T151140Z" creationid="eldesh" creationdate="20200103T151140Z">
        <seg>それらは型クラスの引数の状態を自動的に最大限暗黙に設定し、クラスメソッドのように簡単に使える派生関数を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They often arise when using classes for logical properties, e.g.:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T181633Z" creationid="eldesh" creationdate="20200103T181633Z">
        <seg>それらは論理的性質のためにクラスを使うときにたびたび現れます。例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They support implicit quantification on partially applied type classes (:ref:`implicit-generalization`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T151404Z" creationid="eldesh" creationdate="20200103T151404Z">
        <seg>それらは部分適用された型クラスの暗黙的な量化をサポートします (:ref:`implicit-generalization`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows to precisely mimic the usual unfolding rules of constants.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160913Z" creationid="eldesh" creationdate="20191225T160913Z">
        <seg>これは通常の定数の展開規則と細部に渡って似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows us to follow the same pattern and naming convention for the rest of the chapter.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T110839Z" creationid="eldesh" creationdate="20191227T110839Z">
        <seg>これによってこの章のこれ以降では同じパターンと命名規則に従うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also provides more control on the triggering of instances.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T195103Z" creationid="eldesh" creationdate="20200106T195103Z">
        <seg>これはインスタンスを持ち出すことに関して更なる制御性を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can additionally speed up proof search as the typeclass map can be indexed by such rigid constants (see :ref:`thehintsdatabasesforautoandeauto`).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T190356Z" creationid="eldesh" creationdate="20200106T185508Z">
        <seg>これはさらにそのような固定的な定数によってインデックス出来る型クラスマップによって証明探索を高速化出来ます (see :ref:`thehintsdatabasesforautoandeauto`)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be changed by unsetting the :flag:`Printing Primitive Projection Parameters` flag.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T144624Z" creationid="eldesh" creationdate="20191225T144624Z">
        <seg>これは :flag:`Printing Primitive Projection Parameters` フラグをアンセットすることで変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be expensive as it requires rebuilding hint clauses dynamically, and does not benefit from the invertibility status of the product introduction rule, resulting in potentially more expensive proof-search (i.e. more useless backtracking).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T202212Z" creationid="eldesh" creationdate="20200106T201120Z">
        <seg>これはヒント節の動的な再構築を要求するため高価になりえます、そして積の導入規則の反転可能性から恩恵を得られず、結果として証明探索がより高価になる (つまり、よりバックトラッキングが役に立たなくなる) 可能性があります 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be read in the line declaring the canonical structure ``nat_EQty``, where the first argument to ``Pack`` is the key and its second argument a group of canonical values associated to the key.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T115009Z" creationid="eldesh" creationdate="20191227T115009Z">
        <seg>これは正準構造 ``nat_EQty`` を定義した行の中で読み取ることが出来、ここで ``Pack`` の最初の引数がキーであり、二番目の引数がそのキーに関連付けられた正準値のグループです。</seg>
      </tuv>
    </tu>
    <tu>
      <note>aaaaaaaaaaaa</note>
      <tuv lang="EN-US">
        <seg>This can be used in :cmd:`Hint Extern`’s for typeclass instances (in the hint database ``typeclass_instances``) to allow backtracking on the typeclass subgoals created by the lemma application, rather than doing typeclass resolution locally at the hint application time.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T193000Z" creationid="eldesh" creationdate="20200103T214321Z">
        <seg>これは :cmd:`Hint Extern` の中で (ヒントデータベース ``typeclass_instances`` の中の) 型クラスインスタンスのために、ヒントの適用時にローカルに型クラス解決を行うよりむしろ補題の適用によって作られた型クラスサブゴール上でバックトラッキングを許すために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be useful to make instances of existing objects easily and to reduce proof size by not inserting useless projections.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T192957Z" creationid="eldesh" creationdate="20200103T192957Z">
        <seg>これは簡単に既存のオブジェクトのインスタンスを作り、そして無駄な射影を挿入しないことで証明サイズを縮小するのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can drastically improve performance by calling unification less often, matching syntactic patterns being very quick.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T194126Z" creationid="eldesh" creationdate="20200106T194126Z">
        <seg>これは単一化を呼ぶ頻度が低くなることで劇的にパフォーマンスを改善でき、構文的パターンへのマッチングが非常に高速になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can result in quite different performance behaviors of proof search.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T192908Z" creationid="eldesh" creationdate="20200106T192908Z">
        <seg>これは極めて異なった証明探索の性能挙動を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter explains the basics of canonical structures and how they can be used to overload notations and build a hierarchy of algebraic structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T104458Z" creationid="eldesh" creationdate="20191227T104458Z">
        <seg>この章では正準構造の基本とそれらが記法のオーバーロードや代数構造の階層の構築にどのように使えるかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter presents a quick reference of the commands related to type classes.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T135343Z" creationid="eldesh" creationdate="20200103T135343Z">
        <seg>この章では型クラスに関連したコマンドのクイックリファレンスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class implements a boolean equality test which is compatible with Leibniz equality on some type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T215606Z" creationid="eldesh" creationdate="20200103T140612Z">
        <seg>このクラスはいくつかの型上での Leibniz 等値性と互換性があるような真偽値等値性テストを実装しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command adds an arbitrary list of constants whose type ends with an applied typeclass to the instance database with an optional priority.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T184224Z" creationid="eldesh" creationdate="20200103T202826Z">
        <seg>このコマンドは定数の任意のリストを任意に優先度を伴ってインスタンスデータベースへ追加します。その型は適用された型クラスで終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command allows more global customization of the typeclass resolution tactic.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T210756Z" creationid="eldesh" creationdate="20200106T210756Z">
        <seg>このコマンドは型クラス解決タクティックのより広範囲のカスタマイズを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command also accepts an optional output filename:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T101154Z" creationid="eldesh" creationdate="20191227T101154Z">
        <seg>このコマンドはオプショナルな出力ファイル名も受け付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command can be seen as a generalization of ``Fixpoint``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T212519Z" creationid="eldesh" creationdate="20191221T212519Z">
        <seg>このコマンドは ``Fixpoint`` の一般化と見なすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command declares :token:`qualid` as a canonical structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T182845Z" creationid="eldesh" creationdate="20191225T182845Z">
        <seg>このコマンドは :token:`qualid` を正準構造として定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This command makes the identifiers transparent during typeclass resolution.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T123159Z" creationid="eldesh" creationdate="20200106T123159Z">
        <seg>このコマンドは型クラス解決の間識別子を透明にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This compatibility option (on by default) governs the printing of pattern matching over primitive records.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134151Z" creationid="eldesh" creationdate="20191225T134151Z">
        <seg>この互換性オプション (デフォルトで有効) はプリミティブレコード上でのパターンマッチの表示を抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This compatibility option reconstructs internally omitted parameters at printing time (even though they are absent in the actual AST manipulated by the kernel).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134030Z" creationid="eldesh" creationdate="20191225T134030Z">
        <seg>この互換オプションは表示時に内部的に省略されたパラメータを再構成します (たとえばそれらがカーネルに操作された実際のASTには存在しないものであっても)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This declaration means that any instance of the ``Ord`` class must have an instance of ``EqDec``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T172239Z" creationid="eldesh" creationdate="20200103T172239Z">
        <seg>この定義が意味するところは ``Ord`` クラスのインスタンスは ``EqDec`` のインスタンスを持っていなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This declares singleton classes for reflexive and transitive relations, (see the :ref:`singleton class &lt;singleton-class&gt;` variant for an explanation).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T112217Z" creationid="eldesh" creationdate="20200103T185158Z">
        <seg>これは反射的および推移的関係のシングルトンクラスを宣言します (説明は :ref:`singleton class &lt;singleton-class&gt;` 派生を見てください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This displays the list of global names that are components of some canonical structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185111Z" creationid="eldesh" creationdate="20191225T185111Z">
        <seg>これはいくつかの正準構造のコンポーネントのグローバルな名前のリストを表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is the Reference Manual of the |Coq| proof assistant.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T034931Z" creationid="yamarten" creationdate="20181007T033738Z">
        <seg>この文書は証明アシスタント |Coq| のリファレンスマニュアルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that the resolution is canonical, but can make proof search much more expensive.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T204705Z" creationid="eldesh" creationdate="20200106T204705Z">
        <seg>これはその解が正準であることを保証しますが、証明探索はより高価になりえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This error happens generally when:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144303Z" creationid="eldesh" creationdate="20191221T220022Z">
        <seg>このエラーは一般的に起こります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a Reference Manual, so it is not intended for continuous reading.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144930Z" creationid="yamarten" creationdate="20181104T144930Z">
        <seg>この文書はリファレンスマニュアルであり、通読するものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to ``Hint Resolve ident : typeclass_instances``, except it registers instances for :cmd:`Print Instances`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T184917Z" creationid="eldesh" creationdate="20200103T203059Z">
        <seg>これは :cmd:`Print Instances` できるインスタンスを登録することを除いて ``Hint Resolve ident : typeclass_instances`` に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to ``Hint Transparent, Opaque ident : typeclass_instances``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T190908Z" creationid="eldesh" creationdate="20200106T190908Z">
        <seg>これは ``Hint Transparent, Opaque ident : typeclass_instances`` に相当します。(訳注: 相当しません)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to a regular definition of :token:`ident` followed by the declaration :n:`Canonical Structure @ident`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T185018Z" creationid="eldesh" creationdate="20191225T185018Z">
        <seg>これは :token:`ident` の通常の定義に続いて :n:`Canonical Structure @ident` を定義したのと等しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is similar to the distinction between :cmd:`Parameter` vs. :cmd:`Definition`, or between :cmd:`Declare Module` and :cmd:`Module`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T215124Z" creationid="eldesh" creationdate="20200103T201912Z">
        <seg>これは :cmd:`Parameter` と :cmd:`Definition` または :cmd:`Declare Module` と :cmd:`Module` の差異に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the default behavior.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T143347Z" creationid="eldesh" creationdate="20191226T143347Z">
        <seg>これはデフォルトの振る舞いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is useful for declaring the implicit type of a single variable.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T132819Z" creationid="eldesh" creationdate="20191226T132534Z">
        <seg>これは単一の変数の暗黙型を定義するのに有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very similar to the coercion mechanism of ``Structure`` declarations.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T185823Z" creationid="eldesh" creationdate="20200103T185823Z">
        <seg>これは ``Structure`` 定義のコアーション機構に非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This last test shows that |Coq| is now not only able to type check ``3 == 3``, but also that the infix relation was bound to the ``nat_eq`` relation.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T114525Z" creationid="eldesh" creationdate="20191227T114424Z">
        <seg>この最後のテストは |Coq| がもはや ``3 == 3`` の型検査が出来るだけでなく、中置関係が ``nat_eq`` 関係に束縛されたことを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This latter papers also presents many techniques one can employ to tune the inference of canonical structures.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T105657Z" creationid="eldesh" creationdate="20191227T105657Z">
        <seg>後者の論文は正準構造の推論を調整するために用いることが出来るたくさんのテクニックも述べています。</seg>
      </tuv>
    </tu>
    <tu>
      <note>documentとdocumentationが区別できてないせいでちょっとよろしくない感じになっている。</note>
      <tuv lang="EN-US">
        <seg>This manual does not contain all the documentation the user may need about |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145934Z" creationid="yamarten" creationdate="20181104T145918Z">
        <seg>このマニュアルは |Coq| についてユーザが求める文書が全て含まれているわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <note>http://www.opensource.jp/openpub/ に準拠している。敬体に直した方が自然かもしれない。</note>
      <tuv lang="EN-US">
        <seg>This material (the Coq Reference Manual) may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at http://www.opencontent.org/openpub).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150301Z" creationid="yamarten" creationdate="20181104T150301Z">
        <seg>この作品 (Coq リファレンスマニュアル) はオープン・パブリケーション利用許諾契約書 (v1.0 かそれ以降) で指定された条件と制約に従う限り配布することができる(契約書の最新の版は現在のところ http://www.opencontent.org/openpub/で入手可能である)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may result in confusing errors in case of typos.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T162022Z" creationid="eldesh" creationdate="20191226T143211Z">
        <seg>これはtypoした場合に紛らわしいエラーにつながるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message is followed by an explanation of this impossibility.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201627Z" creationid="eldesh" creationdate="20191221T201627Z">
        <seg>このメッセージにはこの不可能性の説明が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option (on by default since 8.6) respects the dependency order between subgoals, meaning that subgoals on which other subgoals depend come first, while the non-dependent subgoals were put before the dependent ones previously (Coq 8.5 and below).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T192535Z" creationid="eldesh" creationdate="20200106T192535Z">
        <seg>このオプション (8.6 からデフォルトで有効になった) はサブゴール間の依存順序を遵守し、その意味するところは、以前 (Coq 8.5 以下) では他のサブゴールが依存するサブゴールが優先され、一方非依存サブゴールは依存するもの前に置かれるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option (on by default) controls the ability to apply hints while avoiding (functional) eta-expansions in the generated proof term.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T200027Z" creationid="eldesh" creationdate="20200106T200027Z">
        <seg>このオプション (デフォルトで有効) は一般的な証明項の中で (関数的な) イータ展開を避けながらヒントを適用する能力を制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option (on by default) controls the use of typeclass resolution when a unification problem cannot be solved during elaboration/type inference.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T202742Z" creationid="eldesh" creationdate="20200106T202742Z">
        <seg>このオプション (デフォルトで有効) は精緻化/型推論の間に単一化問題が解決できない時に型クラス解決の使用を制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option allows to switch the behavior of instance declarations made through the Instance command.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T205645Z" creationid="eldesh" creationdate="20200106T205645Z">
        <seg>このオプションは Instance コマンドを通じて行われるインスタンス宣言の振る舞いの切り替えるを認めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option, available since Coq 8.6 and off by default, switches the hint application procedure to a filter-then-unify strategy.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T193544Z" creationid="eldesh" creationdate="20200106T193436Z">
        <seg>このオプションは Coq 8.6 から使用可能でデフォルトで無効にされており、ヒント適用手続き filter-then-unify 戦略に切り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This relation is selected whenever ``==`` is used on terms of type nat.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T114702Z" creationid="eldesh" creationdate="20191227T114702Z">
        <seg>この関係は ``==`` が nat 型の項の上で使われるときはいつでも選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This singleton class is a so-called definitional class, represented simply as a definition ``ident binders := term`` and whose instances are themselves objects of this type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T174436Z" creationid="eldesh" creationdate="20200103T192519Z">
        <seg>このシングルトンクラスはいわゆる定義クラスといわれ、``ident binders := term`` という定義として単純に表現され、そのインスタンスはこの型のオブジェクトそれ自体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntax can also be used for pattern matching.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193922Z" creationid="eldesh" creationdate="20191221T193922Z">
        <seg>この構文はパターンマッチングに使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntax is used for declaration of singleton class instances or for directly giving an explicit term of type ``forall binders, Class t1 … tn``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T182251Z" creationid="eldesh" creationdate="20200103T200340Z">
        <seg>この構文はシングルトンクラスインスタンスの宣言または ``forall binders, Class t1 … tn`` 型の明示的な項を直接与えるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tactic uses a different resolution engine than :tacn:`eauto` and :tacn:`auto`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T185101Z" creationid="eldesh" creationdate="20200103T203400Z">
        <seg>このタクティックは :tacn:`eauto` や :tacn:`auto` と異なる(訳注: 制約)解消エンジンを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variant declares a *singleton* class with a single method.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T192151Z" creationid="eldesh" creationdate="20200103T192151Z">
        <seg>この類型は単一のメソッドを持つ *シングルトン* クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>a posteriori をわざわざ使う意味ある？</note>
      <tuv lang="EN-US">
        <seg>This variant declares a class a posteriori from a constant or inductive definition.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T181619Z" creationid="eldesh" creationdate="20200103T193452Z">
        <seg>この派生形は定数や帰納的定義から事後的にクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variant runs resolution with the given hint databases.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T192422Z" creationid="eldesh" creationdate="20200103T212718Z">
        <seg>この派生形は与えられたヒントデータベースでの解消を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This wizard option, in combination with :flag:`Printing All` can help to diagnose failures to unify terms apparently identical but internally different in the Calculus of Inductive Constructions.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T194420Z" creationid="eldesh" creationdate="20191226T194420Z">
        <seg>この達人向けオプションは、:flag:`Printing All` と組み合わせて一見したところ同じだが Calculus of Inductive Constructions では内部的に異なっている項の単一化の失敗を診断するのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Through the ``Inductive`` and ``CoInductive`` commands, when the body of the definition is a record declaration of the form ``Build_``\ `R` ``{`` |p_1| ``:`` |t_1|\ ``; … ;`` |p_n| ``:`` |t_n| ``}``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T154716Z" creationid="eldesh" creationdate="20191225T154423Z">
        <seg>``Inductive`` と ``CoInductive`` コマンドを使うのは、定義のボディーが ``Build_``\ `R` ``{`` |p_1| ``:`` |t_1|\ ``; … ;`` |p_n| ``:`` |t_n| ``}`` という形のレコード定義の時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Through the ``Record`` command, in which case the type has to be non-recursive.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T154558Z" creationid="eldesh" creationdate="20191225T145335Z">
        <seg>``Record`` コマンドを使うと、その場合はその型が非再帰的である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the order of the fields is important.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184013Z" creationid="eldesh" creationdate="20191221T184013Z">
        <seg>従ってフィールドの順序は重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the following example cannot be accepted due to the presence of partial application of `wrong` in the body of `wrong` :</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143635Z" creationid="eldesh" creationdate="20191221T215229Z">
        <seg>従って、以下の例は `wrong` のボディー内の `wrong` の部分適用の存在のため受け入れられません:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To apply a hint, we first check that the goal *matches* syntactically the inferred or specified pattern of the hint, and only then try to *unify* the goal with the conclusion of the hint.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T193905Z" creationid="eldesh" creationdate="20200106T193905Z">
        <seg>ヒントを適用するため、まずそのゴールが推論やそのヒントによって指定されたパターンに構文的に *マッチする* かを検査し、そうなってはじめてそのヒントの結論とゴールを *単一化* しようと試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To build an object of type :n:`@ident`, one should provide the constructor :n:`@ident₀` with the appropriate number of terms filling the fields of the record.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191844Z" creationid="eldesh" creationdate="20191221T191844Z">
        <seg>:n:`@ident` 型のオブジェクトを構築するには、レコードのフィールドを埋める適切な数の項を伴った :n:`@ident₀` コンストラクタを提供する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define recursive records, one can use the ``Inductive`` and ``CoInductive`` keywords, resulting in an inductive or co-inductive record.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200647Z" creationid="eldesh" creationdate="20191221T200319Z">
        <seg>再帰的レコードを定義するためには、``Inductive`` と ``CoInductive`` キーワードを使うことができ、結果は帰納的または余帰納的レコードになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ease compatibility with ordinary record types, each primitive projection is also defined as a ordinary constant taking parameters and an object of the record type as arguments, and whose body is an application of the unfolded primitive projection of the same name.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T163624Z" creationid="eldesh" creationdate="20191225T163617Z">
        <seg>通常のレコード型との互換性を緩和するため、各プリミティブ射影は通常のパラメータと、引数としてそのレコード型のオブジェクトとを取り、そのボディーが同じ名前の非畳み込みプリミティブ射影の適用であるものとしても定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ease the parametrization of developments by typeclasses, we provide a new way to introduce variables into section contexts, compatible with the implicit argument mechanism.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T161540Z" creationid="eldesh" creationdate="20200103T161540Z">
        <seg>開発のパラメータ化を型クラスによって楽にするため、セクションの文脈に変数を導入する、暗黙引数の機構と互換な新しい方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To eliminate the (co-)inductive type, one must use its defined primitive projections.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134716Z" creationid="eldesh" creationdate="20191225T134716Z">
        <seg>(余)帰納的型を排除するためには、その定義されたプリミティブ射影を使わなければならない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To explain the notation ``[find v | t1 ~ t2]`` let us pick one of its instances: ``[find e | EQ.obj e ~ T | "is not an EQ.type" ]``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T204550Z" creationid="eldesh" creationdate="20200102T204550Z">
        <seg>記法 ``[find v | t1 ~ t2]`` を説明するため、具体例の一つ ``[find e | EQ.obj e ~ T | "is not an EQ.type" ]`` を取り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To get to an interesting example we need another base class to be available.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191228T144316Z" creationid="eldesh" creationdate="20191228T144316Z">
        <seg>興味深い例を得るにはもう一つの基本クラスを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To keep the example small, the algebraic structure ``EQ.type`` we are defining is very simplistic, and characterizes terms on which a binary relation is defined, without requiring such relation to validate any property.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T112207Z" creationid="eldesh" creationdate="20191227T112157Z">
        <seg>例を小さく保つため、我々が定義する代数構造 ``EQ.type`` は非常に単純でかつ、ある定義された二項関係上で項を特徴づけ、そのような関係に要求されるどんな性質の正当性の立証もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To reactivate the high-level printing features, use the command ``Unset Printing All``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T101906Z" creationid="eldesh" creationdate="20191226T192844Z">
        <seg>高レベル表示機能を再度有効化するには、``Unset Printing All`` コマンドを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To start using Coq, it is advised to first read a tutorial.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T034900Z" creationid="yamarten" creationdate="20181007T034900Z">
        <seg>Coqを初めて使う方は、まずチュートリアルを読むことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Turn this option on to activate the display of the actual level of each occurrence of :g:`Type`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T193804Z" creationid="eldesh" creationdate="20191226T193732Z">
        <seg>このオプションをオンにすると、出現したそれぞれの :g:`Type` の実際のレベルの表示を有効化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Turning this option on deactivates all high-level printing features such as coercions, implicit arguments, returned type of pattern matching, notations and various syntactic sugar for pattern matching or record projections.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191226T192739Z" creationid="eldesh" creationdate="20191226T192052Z">
        <seg>このオプションを有効にするとコアーション、暗黙引数、パターンマッチングの戻り型、表記法、それにパターンマッチやレコード射影のための様々な糖衣構文などの全ての高レベル表示機能を解除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Turns on the use of primitive projections when defining subsequent records (even through the ``Inductive`` and ``CoInductive`` commands).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T160157Z" creationid="eldesh" creationdate="20191225T160157Z">
        <seg>後続のレコードを (``Inductive`` や ``CoInductive`` コマンドだとしても) 定義するときにプリミティブ射影を有効にします。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tutorial</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145951Z" creationid="yamarten" creationdate="20181104T145951Z">
        <seg>チュートリアル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Classes</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T135226Z" creationid="eldesh" creationdate="20200103T135226Z">
        <seg>型クラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typeclass declarations introduced when this option is set have a more efficient resolution behavior (the option is off by default).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T204841Z" creationid="eldesh" creationdate="20200106T204841Z">
        <seg>このオプションが設定された時に導入された型クラス宣言は、より効率的な解決時の振る舞いを持っています。(このオプションはデフォルトで無効です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typeclass declarations introduced when this option is set have a stricter resolution behavior (the option is off by default).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T203336Z" creationid="eldesh" creationdate="20200106T203336Z">
        <seg>このオプションが設定されたときに導入された型クラス宣言はより厳密な解決時の振る舞いを持ちます。(このオプションはデフォルトで無効です)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typeclasses Transparent, Typclasses Opaque</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T123053Z" creationid="eldesh" creationdate="20200106T122927Z">
        <seg>透明な型クラス、不透明な型クラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typeclasses eauto `:=`</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T210545Z" creationid="eldesh" creationdate="20200106T210545Z">
        <seg>型クラスの eauto `:=`</seg>
      </tuv>
    </tu>
    <tu>
      <note>コードが間違っている。
Fail Check forall (le : type) (n m : obj le), n &lt;= m -&gt; m &lt;= n -&gt; n == m.
が正しい。</note>
      <tuv lang="EN-US">
        <seg>Unfortunately there is still an obstacle to developing the algebraic theory of this new class.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T142210Z" creationid="eldesh" creationdate="20200102T142210Z">
        <seg>残念ながら未だにこの新しいクラスの代数理論の開発の障害があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, these declarations are very verbose.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T161111Z" creationid="eldesh" creationdate="20200102T160649Z">
        <seg>残念ながらこれらの定義は非常に冗長です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use  the keyword ``Inductive`` or ``CoInductive`` instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T202830Z" creationid="eldesh" creationdate="20191221T202820Z">
        <seg>代わりにキーワード ``Inductive`` または ``CoInductive`` を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the :cmd:`Add @table` and :cmd:`Remove @table` commands to update the set of qualids.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193734Z" creationid="eldesh" creationdate="20191221T193734Z">
        <seg>qualid の集合を更新するには :cmd:`Add @table` と :cmd:`Remove @table` コマンドを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User extensions</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150228Z" creationid="yamarten" creationdate="20181104T150228Z">
        <seg>ユーザ拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an empty database (created with :cmd:`Create HintDb` for example) with unfoldable variables and constants as the first argument of ``typeclasses eauto`` hence makes resolution with the local hypotheses use full conversion during unification.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T192254Z" creationid="eldesh" creationdate="20200103T212057Z">
        <seg>展開可能変数と定数を伴う (例えば :cmd:`Create HintDb` で作成された) 空のデータベースを ``typeclasses eauto`` の最初の引数として使い、従って単一化の間、局所的な仮定を使う解消に完全変換を使わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the so-called *Curry-Howard isomorphism*, programs, properties and proofs are formalized in the same language called *Calculus of Inductive Constructions*, that is a :math:`\lambda`-calculus with a rich type system.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T094032Z" creationid="yamarten" creationdate="20181007T082717Z">
        <seg>*カリー・ハワード同型対応* を使えば、プログラム・性質・証明は全て *Calculus of Inductive Constructions* という一つの言語で表現できます。これは :math:`\lambda` 計算にリッチな型システムが付いたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variants:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T192108Z" creationid="eldesh" creationdate="20200103T192108Z">
        <seg>類型:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various informations can be found in the following documents:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145944Z" creationid="yamarten" creationdate="20181104T145944Z">
        <seg>以下の文書からも様々な情報を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We amend that by equipping ``nat`` with a comparison relation.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T113256Z" creationid="eldesh" creationdate="20191227T113244Z">
        <seg>これを ``nat`` に比較関係を授けることで修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We build an infix notation == for a comparison predicate.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T105803Z" creationid="eldesh" creationdate="20191227T105803Z">
        <seg>比較述語のための中置記法 == を構築します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can now formulate out first theorem on the objects of the ``LEQ`` structure.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T152150Z" creationid="eldesh" creationdate="20200102T152150Z">
        <seg>我々は今や ``LEQ`` 構造のオブジェクト上で最初の定理を定式化することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We choose the class of types that are equipped with an order relation, to which we associate the infix ``&lt;=`` notation.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191228T144507Z" creationid="eldesh" creationdate="20191228T144448Z">
        <seg>中置 ``&lt;=`` 記法を伴った順序関係を装備した型のクラスを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We describe here extensions of |Gallina|’s syntax.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184246Z" creationid="eldesh" creationdate="20191221T184246Z">
        <seg>ここでは |Gallina| の構文の拡張について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We invite the interested reader to refer to this paper for all the details that are omitted here for brevity.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T125611Z" creationid="eldesh" creationdate="20191227T105020Z">
        <seg>簡潔さのためにここでは省略した全ての詳細について興味のある読者にはこの論文を参照することを勧めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We know how to use ``== `` on base types, like ``nat``, ``bool``, ``Z``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T122137Z" creationid="eldesh" creationdate="20191227T122137Z">
        <seg>私たちは ``nat``、``bool``、``Z`` のような基本型上で ``==`` をどのように使うかを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We need some infrastructure for that.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T203646Z" creationid="eldesh" creationdate="20200102T203646Z">
        <seg>いくらかの基盤が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We need to define a new class that inherits from both ``EQ`` and ``LE``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191229T131007Z" creationid="eldesh" creationdate="20191229T131007Z">
        <seg>``EQ`` と ``LE`` の両方から派生した新しいクラスを定義する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We now have all we need to create a compact “packager” to declare instances of the ``LEQ`` class.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T215207Z" creationid="eldesh" creationdate="20200102T210949Z">
        <seg>今や我々は ``LEQ`` クラスのインスタンスを定義するためのコンパクトな "荷造り業者" を作るために必要なものを全て持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We recommend using the various indexes to quickly locate the documentation you are looking for.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144937Z" creationid="yamarten" creationdate="20181104T144937Z">
        <seg>目的の文書を素早く見つけるために、色々な索引を使うことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We use Coq modules as namespaces.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191227T110641Z" creationid="eldesh" creationdate="20191227T110631Z">
        <seg>Coq のモジュールを名前空間として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We’ll use the following example class in the rest of the chapter:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200104T215245Z" creationid="eldesh" creationdate="20200103T140229Z">
        <seg>この章の残りでは以下の例示クラスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What the user provides is a proof of this statement for ``n`` and ``m`` of type ``nat`` and a proof that the pair constructor preserves this property.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T162609Z" creationid="eldesh" creationdate="20200102T162522Z">
        <seg>ユーザが提供したものは ``n`` と ``m`` の型 ``nat`` についてのこのステートメントの証明とペアコンストラクタがこの性質を保存するという証明です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When `qualid` denotes a projection, the syntax `term.(qualid)` is equivalent to `qualid term`, the syntax `term.(qualid` |arg_1| |arg_n| `)` to `qualid` |arg_1| `…` |arg_n| `term`, and the syntax `term.(@qualid` |term_1| |term_n| `)` to `@qualid` |term_1| `…` |term_n| `term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T200620Z" creationid="eldesh" creationdate="20191221T195318Z">
        <seg>`qualid` が射影を意味するとき、`term.(qualid)` という構文は `qualid term` と等しく、`term.(qualid` |arg_1| |arg_n| `)` は `qualid` |arg_1| `…` |arg_n| `term` と、`term.(@qualid` |term_1| |term_n| `)` という構文は `@qualid` |term_1| `…` |term_n| `term` と等しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a solution to the typeclass goal of this class is found, we never backtrack on it, assuming that it is canonical.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T205007Z" creationid="eldesh" creationdate="20200106T205007Z">
        <seg>このクラスの型クラスゴールの解が見つかったとき、けっしてバックトラックを行わず、それが正準であると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>though の意味が分からん</note>
      <tuv lang="EN-US">
        <seg>When a type is declared with primitive projections, its :g:`match` construct is disabled (see :ref:`primitive_projections` though).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134536Z" creationid="eldesh" creationdate="20191225T134523Z">
        <seg>ある型がプリミティブ射影によって定義されたとき、その :g:`match` による構成は無効化されます (:ref:`primitive_projections` 参照).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a typeclass resolution is launched we ensure that it has a single solution or fail.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T204558Z" creationid="eldesh" creationdate="20200106T204530Z">
        <seg>型クラス解決が起きた時、それが単一の解を持たないならば失敗することを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>core とは？</note>
      <tuv lang="EN-US">
        <seg>When called with no arguments, ``typeclasses eauto`` uses the ``typeclass_instances`` database by default (instead of core).</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T185319Z" creationid="eldesh" creationdate="20200103T204408Z">
        <seg>引数なしで呼ばれたときは、``typeclasses eauto`` はデフォルトで (コアの替わりに) ``typeclass_instances`` データベースを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called with specific databases (e.g. with), ``typeclasses eauto`` allows shelved goals to remain at any point during search and treat typeclass goals like any other.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T211407Z" creationid="eldesh" creationdate="20200103T211407Z">
        <seg>特定のデータベース (例. with) を伴って呼ばれたとき、``typeclasses eauto`` は先送りにされたゴールを検索中のどの時点でもとどまることを許し、型クラスゴールを他と同じように扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When considering local hypotheses, we use the transparent state of the first hint database given.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200105T191119Z" creationid="eldesh" creationdate="20200103T211706Z">
        <seg>局所的な仮定を考えるとき、我々は与えられた最初のヒントデータベースの透過性状態を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is off, they fail with an error instead.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T210502Z" creationid="eldesh" creationdate="20200106T210502Z">
        <seg>無効なときは、替わりにエラーを伴って失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is on (the default), instances that have unsolved holes in their proof-term silently open the proof mode with the remaining obligations to prove.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T210421Z" creationid="eldesh" creationdate="20200106T205951Z">
        <seg>それが有効 (デフォルト) なとき、証明項に未解決のホールがあるインスタンスは残っている証明課題を伴って証明モードを開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When looking for unifications of a goal with an instance of this class, we “freeze” all the existentials appearing in the goals, meaning that they are considered rigid during unification and cannot be instantiated.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T204029Z" creationid="eldesh" creationdate="20200106T204029Z">
        <seg>このクラスのインスタンスによりゴールの単一化を求めている時、そのゴールに現れる全ての存在量化された変数を "凍結" します。これは単一化の間固定され、インスタンス化できないと見なされることを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When one calls a class method, a constraint is generated that is satisfied only in contexts where the appropriate instances can be found.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T144359Z" creationid="eldesh" creationdate="20200103T144359Z">
        <seg>クラスメソッドを呼ぶとき、ある制約が生成され、それは適切なインスタンスが見つかる文脈の中でのみ充足されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the :flag:`Primitive Projections` option is on, definitions of record types change meaning.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191225T134252Z" creationid="eldesh" creationdate="20191225T134252Z">
        <seg>:flag:`Primitive Projections` オプションが有効な時、レコード型の定義は意味を変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this option on, when a unification fails, typeclass resolution is tried before launching unification once again.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T202939Z" creationid="eldesh" creationdate="20200106T202939Z">
        <seg>このオプションが有効なことにより、単一化が失敗したとき、再度単一化を起動する前に型クラス解決が試行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override the display format for specified types by adding entries to these tables:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T193229Z" creationid="eldesh" creationdate="20191221T193229Z">
        <seg>これらの表にエントリを追加することで特定の型の表示形式を上書きすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``Class Id (`` |p_1| ``:`` |t_1| ``) ⋯ (`` |p_n| ``:`` |t_n| ``) [: sort] := {`` |f_1| ``:`` |u_1| ``; ⋮`` |f_m| ``:`` |u_m| ``}.``</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T135751Z" creationid="eldesh" creationdate="20200103T135751Z">
        <seg>``Class Id (`` |p_1| ``:`` |t_1| ``) ⋯ (`` |p_n| ``:`` |t_n| ``) [: sort] := {`` |f_1| ``:`` |u_1| ``; ⋮`` |f_m| ``:`` |u_m| ``}.``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``Instance ident : Id`` |p_1| ``⋯`` |p_n| ``:= {`` |f_1| ``:=`` |t_1| ``; ⋮`` |f_m| ``:=`` |t_m| ``}.``</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T135758Z" creationid="eldesh" creationdate="20200103T135758Z">
        <seg>``Instance ident : Id`` |p_1| ``⋯`` |p_n| ``:= {`` |f_1| ``:=`` |t_1| ``; ⋮`` |f_m| ``:=`` |t_m| ``}.``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``Pack`` is a notation, hence it is not type checked at the time of its declaration.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200102T213955Z" creationid="eldesh" creationdate="20200102T213955Z">
        <seg>``Pack`` は記法であり、従ってその定義時点では型検査されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``Structure`` is a synonym of the keyword ``Record``.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T201423Z" creationid="eldesh" creationdate="20191221T201423Z">
        <seg>``Structure`` はキーワード ``Record`` の別名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``debug`` In debug mode, the trace of successfully applied tactics is printed.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T210924Z" creationid="eldesh" creationdate="20200106T210924Z">
        <seg>``debug`` デバッグモードでは、成功裏に適用されたタクティックのトレースが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``depth`` This sets the depth limit of the search.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T211031Z" creationid="eldesh" creationdate="20200106T211031Z">
        <seg>``depth`` これはその検索の深さ制限を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``dfs, bfs`` This sets the search strategy to depth-first search (the default) or breadth-first search.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200106T211016Z" creationid="eldesh" creationdate="20200106T211016Z">
        <seg>``dfs, bfs`` これは検索戦略を深さ優先探索 (デフォルト) または幅優先探索に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``typeclasses eauto`` is a multi-goal tactic.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20200103T204006Z" creationid="eldesh" creationdate="20200103T204006Z">
        <seg>``typeclasses eauto`` はマルチゴールタクティックです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``{measure`` `term` `ident` ``}`` with `ident` being the decreasing argument and `term` being a function from type of `ident` to ``nat`` for which value on the decreasing argument decreases (for the ``lt`` order on ``nat``) at each recursive call of `term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T145258Z" creationid="eldesh" creationdate="20191222T134341Z">
        <seg>``{measure`` `term` `ident` ``}`` ここで `ident` は減少する引数であり、`term` は `ident` の型から ``nat`` への関数であり、その減少引数上の値は `term` の再帰呼び出し毎に減少します (``nat`` 上なら ``lt`` 順序に沿って)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>``{wf`` `term` `ident` ``}`` with `ident` being the decreasing argument and `term` an ordering relation on the type of `ident` (i.e. of type `T`\ :math:`_{\sf ident}` → `T`\ :math:`_{\sf ident}` → ``Prop``) for which the decreasing argument decreases at each recursive call of `term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T134728Z" creationid="eldesh" creationdate="20191222T134728Z">
        <seg>``{wf`` `term` `ident` ``}`` ここで `ident` は減少する引数であり、`term` は `ident` の型上の順序関係 (i.e. `T`\ :math:`_{\sf ident}` → `T`\ :math:`_{\sf ident}` → ``Prop`` という型) であり、その減少引数は `term` の再帰呼び出し毎に減少します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`functional inversion` will not be available for the function.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144547Z" creationid="eldesh" creationdate="20191221T220522Z">
        <seg>その関数についての `functional inversion` が使えるようになりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ident_complete` and `ident_correct` which are inversion information linking the function and its graph.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T133355Z" creationid="eldesh" creationdate="20191222T132941Z">
        <seg>`ident_complete` と `ident_correct` は関数とそのグラフを紐付ける反転情報です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`ident_rect`, `ident_rec` and `ident_ind`, which reflect the pattern matching structure of `term` (see :cmd:`Inductive`);</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T131331Z" creationid="eldesh" creationdate="20191221T221217Z">
        <seg>`ident_rect` と `ident_rec` と `ident_ind` は `term` (:cmd:`Inductive` 参照) のパターンマッチ構造を反映します;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in which case the correctness of :n:`@type₃` may rely on the instance :n:`@term₂` of :n:`@ident₂` and :n:`@term₂` may in turn depend on :n:`@ident₁`.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T191007Z" creationid="eldesh" creationdate="20191221T185905Z">
        <seg>この場合 :n:`@type₃` の正しさは :n:`@ident₂` のインスタンスである :n:`@term₂` に依存し、:n:`@term₂` は :n:`@ident₁` に依存するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>manifest) fields.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T185315Z" creationid="eldesh" creationdate="20191221T185315Z">
        <seg></seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>than like this:</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143311Z" creationid="eldesh" creationdate="20191221T214431Z">
        <seg>これより良いでしょう:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the definition is not a *pattern matching tree* as explained above.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144855Z" creationid="eldesh" creationdate="20191221T220305Z">
        <seg>その定義は上で説明したような *パターンマッチングツリー* ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the definition uses pattern matching on dependent types, which ``Function`` cannot deal with yet.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T144335Z" creationid="eldesh" creationdate="20191221T220124Z">
        <seg>その定義は依存型上のパターンマッチを使っており、``Function`` はまだそれを扱うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the first identifier :token:`ident` is the name of the defined record and :token:`sort` is its type.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T171245Z" creationid="eldesh" creationdate="20191221T171245Z">
        <seg>最初の識別子 :token:`ident` は定義されたレコードの名前であり、:token:`sort` はその型です。</seg>
      </tuv>
    </tu>
    <tu>
      <note>意図がちゃんとわかってない。「型検査器であり、証明アシスタントでもある」「証明アシスタントではタクティックというものを使う」の2点か？そもそもタクティックを言語と呼ぶのに違和感があるので、先を見てから戻ってきたい。</note>
      <tuv lang="EN-US">
        <seg>|Coq| also provides an interactive proof assistant to build proofs using specific programs called *tactics*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T112633Z" creationid="yamarten" creationdate="20181007T101451Z">
        <seg>また、|Coq| は、 *タクティック* と呼ばれるプログラムを用いて証明を構築する、対話的証明アシスタントも提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>|Gallina| is the kernel language of |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191221T184208Z" creationid="eldesh" creationdate="20191221T184208Z">
        <seg>|Gallina| は |Coq| の核言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <note>term_0 とは</note>
      <tuv lang="EN-US">
        <seg>|term_0| must be built as a *pure pattern matching tree* (:g:`match … with`) with applications only *at the end* of each branch.</seg>
      </tuv>
      <tuv lang="JA" changeid="eldesh" changedate="20191222T143345Z" creationid="eldesh" creationdate="20191221T214806Z">
        <seg>|term_0| は 各ブランチの *末尾* のみで適用される *純粋パターンマッチングツリー* (:g:`match … with`) として構築されなければなりません。</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
